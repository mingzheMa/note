import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as l,d as a}from"./app.002a81c8.js";const t={},r=a('<h1 id="渲染原理" tabindex="-1"><a class="header-anchor" href="#渲染原理" aria-hidden="true">#</a> 渲染原理</h1><ul><li>渲染：构成虚拟dom树，将虚拟dom树显示在页面上</li><li>渲染流程：获取react元素 =&gt; 构建react节点 =&gt; 根据react节点渲染</li></ul><h2 id="react元素" tabindex="-1"><a class="header-anchor" href="#react元素" aria-hidden="true">#</a> react元素</h2><p>通过React.createElement或者jsx创建的对象，对象上有type属性标志着该节点的类型：字符串（react节点）、函数（组件）、类（类组件）</p><h2 id="react节点" tabindex="-1"><a class="header-anchor" href="#react节点" aria-hidden="true">#</a> react节点</h2><p>专注于渲染dom元素的对象，渲染时react会根据react元素创建react节点，而react节点会形成虚拟dom树</p><h4 id="节点类型" tabindex="-1"><a class="header-anchor" href="#节点类型" aria-hidden="true">#</a> 节点类型</h4><ul><li>React Dom节点：由字符串React元素类型创建</li><li>React 组件节点：由函数/类React元素类型创建</li><li>React 文本节点：由字符串创建</li><li>React 空节点：由null、undefiled、false、true创建</li><li>React 数组节点：由数组创建</li></ul><h2 id="首次渲染" tabindex="-1"><a class="header-anchor" href="#首次渲染" aria-hidden="true">#</a> 首次渲染</h2><ul><li>. ReactDOM.render从第一个参数开始创建节点</li><li>到页面上） <ul><li>Dom节点：通过document.createElement创建，根据props属性（除了children）设置创建真实dom属性，遍历react元素props.children属性(根据每一项重新递归函数)</li><li>文本节点：通过document.createTextNode创建</li><li>空节点：不创建真实Dom元素，但保留占位节点</li><li>数组节点：遍历数组每一项(根据每一项重新递归函数)</li><li>组件节点： <ul><li>函数组件：执行该函数，将props和ref传递给函数参数，得到返回结果(重新递归函数)</li><li>类组件：创建类的实例，执行生命周期函数static getDerivedStateFromProps，执行生命周期函数runder拿到返回结果(重新递归函数)，runder执行结束后将该组件的生命周期函数componentDidMoun加入执行队列，当整个虚拟dom树构建完毕后执行该队列</li></ul></li></ul></li></ul><ol start="3"><li>将生成的虚拟dom树保存，以便后面更新比较</li><li>将之前创建的dom元素加入到容器中</li></ol><h2 id="更新渲染" tabindex="-1"><a class="header-anchor" href="#更新渲染" aria-hidden="true">#</a> 更新渲染</h2><h3 id="更新场景" tabindex="-1"><a class="header-anchor" href="#更新场景" aria-hidden="true">#</a> 更新场景</h3><ol><li>使用ReactDOM.render重新渲染根节点</li><li>使用setState更新类组件状态</li></ol><h3 id="reactdom-render" tabindex="-1"><a class="header-anchor" href="#reactdom-render" aria-hidden="true">#</a> ReactDOM.render</h3><p>卸载所有节点，将新节点重新渲染，走首次渲染逻辑</p><h3 id="setstate" tabindex="-1"><a class="header-anchor" href="#setstate" aria-hidden="true">#</a> setState</h3><p>例如我们在class A中触发了setState</p><ol><li><p>执行组件A生命周期函数static getDerivedStateFromProps</p></li><li><p>执行组件A生命周期函数shouldComponentUpdate，如果返回false，更新终止</p></li><li><p>执行组件A生命周期函数runder，递归返回的子节点进行 对比更新（diff）</p></li><li><p>将组件A生命周期函数getSnapshotBeforeUpdate放入执行队列</p></li><li><p>将组件A生命周期函数componentDidUpdate放入执行队列</p></li><li><p>更新虚拟dom树（diff过程，可能会有增加、删除、修改节点的操作，会把对应节点的对应生命周期加入队列，后面我们重点说）</p></li><li><p>挂载虚拟dom树</p></li><li><p>执行队列中生命周期函数componentDidMount（如果更新后有新增组件）</p></li><li><p>执行队列中生命周期函数getSnapshotBeforeUpdate（组件A以及判断为更新的子节点）</p></li><li><p>执行队列中生命周期函数componentDidUpdate（组件A以及判断为更新的子节点）</p></li><li><p>执行队列中生命周期函数componentWillMount（如果有子节点删除了）</p></li></ol><h3 id="diff" tabindex="-1"><a class="header-anchor" href="#diff" aria-hidden="true">#</a> diff</h3><p>react为了提升对比效率做出如下假设：</p><ul><li>节点的层级不发生变动，只对比相同层级的相同位置</li><li>节点类型相同则节点相同，否则为不同：react节点的type相同</li><li>多个相同兄弟节点通过key进行对比，key的概念我们后面说</li></ul><p>react会根据旧虚拟dom树和新虚拟dom树进行diff</p><p>找到相同结构的相同节点（层级一样，位置一样，节点类型一样）则进行对比，这里说节点相同，并不代表节点没变化，可能属性变化</p><h4 id="对比结果相同" tabindex="-1"><a class="header-anchor" href="#对比结果相同" aria-hidden="true">#</a> 对比结果相同</h4><ul><li>空节点：什么也不做</li><li>文本节点：重用之前的真实DOM元素，记录更改的属性以便后续更新</li><li>DOM节点：重用之前的真实DOM元素，记录更改的属性以便后续更新，遍历子节点递归进行对比</li><li>函数组件节点：调用函数，递归返回结果中的根节点进行对比</li><li>数组节点：遍历数组，递归对比数组中的每一项</li><li>类组件节点： <ul><li>重用之前的类实例对象</li><li>调用生命周期函数static getDerivedStateFromProps</li><li>调用生命周期函数shouldComponentUpdate，如果返回false，当前组件更新终止</li><li>调用生命周期函数runder，递归返回结果中的根节点进行对比</li><li>对比更新结束后将生命周期函数getSnapshotBeforeUpdate放入执行队列</li><li>将生命周期函数componentDidUpdate放入执行队列</li></ul></li></ul><h4 id="对比结果不相同" tabindex="-1"><a class="header-anchor" href="#对比结果不相同" aria-hidden="true">#</a> 对比结果不相同</h4><ol><li>创建新节点（执行新节点render）</li><li>卸载旧节点 <ul><li>类组件节点： <ul><li>卸载改节点</li><li>调用生命周期函数componentWillUnMount</li><li>递归卸载子节点</li></ul></li><li>其他节点： <ul><li>卸载该节点</li><li>递归卸载子节点</li></ul></li></ul></li></ol><h4 id="没有对比的节点" tabindex="-1"><a class="header-anchor" href="#没有对比的节点" aria-hidden="true">#</a> 没有对比的节点</h4><ul><li>没有新节点，判断为节点删除，直接卸载</li><li>没有旧节点，判断为节点新增，直接创建</li></ul><h3 id="key" tabindex="-1"><a class="header-anchor" href="#key" aria-hidden="true">#</a> key</h3><p>在节点（除了空、文本、数组节点）上可以添加key属性</p><p>该属性是用来在diff中新节点寻找同层级相同key的旧节点，判断为两个节点一致（即使同一层级顺序不一样），走对比相同流程</p>',33),d=[r];function n(o,h){return i(),l("div",null,d)}const s=e(t,[["render",n],["__file","渲染原理.html.vue"]]);export{s as default};
