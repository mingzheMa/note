# Vue.$mount

<font color="#999">文件路径: src/platforms/web/entry-runtime-with-compiler.js</font>

```js
// 保存通用的mount方法，对mount方法进行二次封装，当前包为浏览器环境，并且需要编译器，针对这些特性构建mount方法
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element, // 挂载容器
  hydrating?: boolean
): Component {
  // 获取挂载容器真实dom
  el = el && query(el)

  // 获取Vue实例配置
  const options = this.$options
  // 如果没有配置render函数，则需要将 template 转化为 render 函数
  if (!options.render) {
    // 获取模板配置
    let template = options.template
    // 统一模板配置为dom字符串，例如："<div><Hellow /></div>"
    if (template) {
      if (typeof template === "string") {
        if (template.charAt(0) === "#") {
          // 如果模板是一个id选择器，则获取dom.innerHTML为模板
          template = idToTemplate(template)
        }
      } else if (template.nodeType) {
        // 如果模板配置为真实dom，直接提取innerHML
        template = template.innerHTML
      } else {
        return this
      }
    } else if (el) {
      // 如果模板配置不存在，则获取 el 配置的 dom.outerHTML
      template = getOuterHTML(el)
    }

    if (template) {
      // 将模板转化为render函数
      const { render, staticRenderFns } = compileToFunctions(
        template,
        {
          outputSourceRange: process.env.NODE_ENV !== "production",
          shouldDecodeNewlines,
          shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        },
        this
      )
      options.render = render
      options.staticRenderFns = staticRenderFns
    }
  }
  return mount.call(this, el, hydrating)
}
```

我们重新回到 entry-runtime-with-compiler 中观察 mount 方法，可以看见这是对原有<code>Vue.prototype.$mount</code>方法的二次封装（不同平台的挂载方式不同），经过一系列判断将<code>template</code>参数转化为 HTML 字符串，在通过<code>compileToFunctions</code>方法构建<code>render</code>函数

这是针对编译器做的一层封装，接下来我们来看针对浏览器环境创建的 <code>$mount</code> 函数

<font color="#999">文件路径: src/platforms/web/runtime/index.js</font>

```js
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  // 调用挂载组件函数进行挂载Vue根实例
  return mountComponent(this, el, hydrating)
}
```

vue 无论根实例还是组件实例，最终都是通过 <code>mountComponent</code> 函数进行挂载，该函数是环境通用的挂载函数

<font color="#999">文件路径: src/core/instance/lifecycle.ts</font>

```js
export function mountComponent(
  vm: Component, // Vue根实例
  el: ?Element, // 挂载容器dom
  hydrating?: boolean
): Component {
  // 容器dom挂载到Vue根实例配置上
  vm.$el = el
  
  // 标准化render配置
  if (!vm.$options.render) {
    // 如果render配置不存在，则赋值一个空函数
    vm.$options.render = createEmptyVNode
  }
  // 执行beforeMount生命周期
  callHook(vm, "beforeMount")

  // Vue根实例更新函数
  const updateComponent = () => {
    vm._update(vm._render(), hydrating)
  }

  // 创建一个监听器，用于通知该实例更新视图
  new Watcher(
    vm, // 监听的实例
    updateComponent, // 更新视图时调用的函数
    noop,
    {
      // 在updateComponent函数触前会触发before配置函数
      before() {
        if (vm._isMounted && !vm._isDestroyed) {
          callHook(vm, "beforeUpdate")
        }
      }
    },
    true /* isRenderWatcher */
  )
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, "mounted")
  }
  return vm
}
```

<code>mountComponent</code>大致做了以下事情

1. 触发生命周期<code>beforeMount</code>
2. 构建 Watcher 实例，该实例用于更新依赖，如果在构建时没有配置<code>option.lazy = true</code>则会在构建时立即触发<code>getter</code>，也就是传入的<code>updateComponent</code>函数，函数直接调用<code>vm._update</code>来更新DOM
3. 触发生命周期<code>mounted</code>

<code>$mount</code> 函数是在整个库打包环节挂载，因为 vue 可以在很多环境下运行，这些环境有不同的挂载方式，因此在某个环境的打包前，需要将 <code>$mount</code> 函数挂载到 Vue 构造函数上，用来减少代码体积