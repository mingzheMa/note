# 项目构建相关

这里并不探讨vue3的源码，只是为了学习vue3项目构建中使用的一些技术

## monorepo 仓库管理方式

vue3使用的是 **monorepo** 和 **TypeScript** 管理和开发代码，monorepo解释为单体仓库（mono repo），将耦合度高或依赖性强的项目整合到一个仓库下，通过人为的规则将这些项目划分开

vue3目录如下，将各个功能拆分出单个项目，都放在 <code>vue3/core/packages</code> 中

```txt
vue3/core
├── packages
│   ├── compiler-core
│   ├── compiler-dom
│   ├── compiler-sfc
│   ├── compiler-ssr
│   ├── reactivity
│   ├── reactivity-transform
│   ├── runtime-core
│   ├── runtime-dom
│   ├── runtime-test
│   ├── server-renderer
│   ├── sfc-playground
│   ├── shared
│   ├── size-check
│   ├── template-explorer
│   ├── vue
└── └── vue-compat
```

### monorepo 和 multirepos

**multirepos** 是多体仓库，这是比较常用的管理方式，每一个仓库下只存放该项目的代码

从multirepos迁移到monorepo，就是将所有仓库都合并在一起

```txt
/project1
/project2
/project3

↑ 合并为 ↓

/monorepo/project/project1
/monorepo/project/project2
/monorepo/project/project3
```

### monorepo 优点

- **代码透明**，业务相关的项目都在一个仓库中，使得某个项目组可以观察到所有项目的代码，更好的团队协作
- **更好的依赖管理**，一些公共库不需要包管理工具，直接根据路径导入
- **版本冲突**，由于公共库直接导入使用，所以该项目使用的公共库一直是最新版本，减少版本冲突
- **代码风格**，有利于统一整个代码风格
- **重大更新**，某个项目有重大变更其他的项目组在拉取代码时可以观察到，如果与变更项目依赖部分产生影响能及时发现
- **重构或更新**，如果一个业务穿插多个项目，可以在一个分支中完成
- **CI/CD**，可以使用同一套CI/CD部署

### monorepo 缺点

- **仓库庞大**，一些全局的命令会非常耗时，例如：git pull
- **污染主分支**，如果一个问题分支合并到主分支上，可能会影响所有项目，比较考验开发和审核的规则以及相关人员的素质
- **commit增多审查困难**，合并仓库就会导致commit增多，导致code review困难
- **权限管理**，gitHub并没有仓库下文件的管理系统

### monorepo 最佳实践

- 规范仓库中项目目录，便于查找
- 尽量保持分支的纯净
- 一次性提升所有依赖，减少出现版本冲突的情况
- git中使用浅克隆和分支过滤处理仓库
- 使用一些monorepo管理器，例如：lerna

## Vue3 构建结果

仓库中 Vue 项目就是整个 vue 包的入口，目录为 <code>vue3/core/packages/vue</code>，可以使用仓库根目录下的命令 <code>pnpm build</code> 对仓库中每个项目进行打包，打包后在 <code>vue3/core/packages/vue/dist</code> 中可以看到 vue 包的所有版本

```txt{2,5,7,8,10,12,13}
vue3/core/packages/vue/dist
├── vue.cjs.js
├── vue.cjs.prod.js
├── vue.d.ts
├── vue.esm-browser.js
├── vue.esm-browser.prod.js
├── vue.esm-bundler.js
├── vue.global.js
├── vue.global.prod.js
├── vue.runtime.esm-browser.js
├── vue.runtime.esm-browser.prod.js
├── vue.runtime.esm-bundler.js
├── vue.runtime.global.js
└── vue.runtime.global.prod.js
```

除了TS声明文件 <code>.d.ts</code> 和 压缩后的代码 <code>.prod.js</code> 文件剩下的有7个版本

- <code>vue.cjs.js</code>，commonJS模块的版本
- <code>vue.esm-browser.js</code>，用于浏览器原生ES模块导入的版本，例如：<code>\<script type="module"></code>
- <code>vue.esm-bundler.js</code>，在构建工具中使用原声模块导入的版本
- <code>vue.global.js</code>，全局变量的版本，用于cdn引入

<code>vue.runtime.xxx.js</code>，为各个版本的运行时版，是没有编译器部分代码，因为在构建工具中可以使用 <code>vue-loader</code> 来完成编译，这样可以减少代码包体积。上面这些为完全版，是带有编译器部分的代码

> 编译器是将模板转化成渲染函数，例如：\<div>123\</div> => h("div", "123")

## esbuild 打包

在vue3开发阶段使用的就是esbuild打包

### esbuild 特点

![](./esbuild.png)

esbuild是js打包工具，主要针对esm，其速度是webpack的很多倍，功能如下：

- 极快的速度，无需缓存
- 支持 ES6 和 CommonJS 模块
- 支持对 ES6 模块进行 tree shaking
- API 可同时用于 JavaScript 和 Go
- 兼容 TypeScript 和 JSX 语法
- 支持 Source maps
- 支持 Minification
- 支持 plugins

为什么这么快（暂时不研究只做了解）

- Go语言编写，比JavaScript运行效率更高（据说JS是毫秒级，Go是纳秒级）
- 代码都是官方编写，没有使用第三方依赖，更方便优化性能
- 避免不需要的内存分配

### 在vue3中的应用

vue3的开发中用到了esbuild打包

```json
{
  "private": true,
  "version": "3.2.45",
  "packageManager": "pnpm@7.1.0",
  "scripts": {
    "dev": "node scripts/dev.js"
  },
}
```

vue3仓库中的 <code>package.json</code> 中有两个命令，<code>dev</code> 和 <code>dev-esm</code> 都是运行开发构建，它们都运行了 <code>scripts/dev.js</code> 脚本

```js
// @ts-check
const { build } = require('esbuild') // 使用esbuild打包
const nodePolyfills = require('@esbuild-plugins/node-modules-polyfill') // 如果是node环境打包需要导入node内置模块
const { resolve, relative } = require('path')
const args = require('minimist')(process.argv.slice(2)) // 解析出命令行参数

const target = args._[0] || 'vue' // 参数中需要打包的项目
const format = args.f || 'global' // 打包的版本（cjs、esm-browser、esm-bundler、global）
const inlineDeps = args.i || args.inline // 项目是否是内联的，如果是内联的则在打包的时候将一些库参与打包
const pkg = require(resolve(__dirname, `../packages/${target}/package.json`)) // 需要打包项目的package.json

// 标准化打包结果配置，针对cjs、esm-browser、esm-bundler、global版本、
const outputFormat = format.startsWith('global') 
  ? 'iife' // 如果是global版本则打包配置是立即执行函数
  : format === 'cjs'
  ? 'cjs' // 如果是commonJS版本
  : 'esm' // 如果是ESModule版本

// 标准化打包结果配置，针对运行时版和完全版
const postfix = format.endsWith('-runtime')
  ? `runtime.${format.replace(/-runtime$/, '')}`
  : format

// 构建输出文件配置
const outfile = resolve(
  __dirname,
  `../packages/${target}/dist/${
    target === 'vue-compat' ? `vue` : target
  }.${postfix}.js`
)

// 构建报错信息，构建结果的文件路径
const relativeOutfile = relative(process.cwd(), outfile)

let external = [] // 配置不参与打包的库，但是导入语句会保留

// 启用打包
build({
  entryPoints: [resolve(__dirname, `../packages/${target}/src/index.ts`)], // 打包入口设置为当前需要打包的项目
  outfile, // 输出目录为打包项目中的dist文件夹
  bundle: true, // 将依赖文件打包成一个文件
  external, // 打包结果中排除某些文件，但是保留导入语句
  sourcemap: true, // 源码地图
  format: outputFormat, // 打包的模块规则
  globalName: pkg.buildOptions?.name, // 全局变量名称，设置format: iife才有效，打包结果为 var 全局变量名称 = (() => {return xxx})()
  platform: format === 'cjs' ? 'node' : 'browser', // 打包结果运行环境
  plugins: // 插件，如果项目配置了enableNonBrowserBranches表示需要再飞浏览器的环境下运行
    format === 'cjs' || pkg.buildOptions?.enableNonBrowserBranches
      ? [nodePolyfills.default()] // 导入node内置模块
      : undefined,
  define: { // 自定义一些全局变量
    __COMMIT__: `"dev"`, // 打包环境
    __VERSION__: `"${pkg.version}"`, // 项目版本
    __DEV__: `true`, // 是否为开发环境
    __TEST__: `false`, // 是否为测试环境
    __BROWSER__: String(
      format !== 'cjs' && !pkg.buildOptions?.enableNonBrowserBranches
    ), // 是否为浏览器环境
    __GLOBAL__: String(format === 'global'), // 是否是global版本的包
    __ESM_BUNDLER__: String(format.includes('esm-bundler')), // 是否是esm-bundle版本的包
    __ESM_BROWSER__: String(format.includes('esm-browser')), // 是否是esm-browser版本的包
    __NODE_JS__: String(format === 'cjs'), // 是否是node环境
    __SSR__: String(format === 'cjs' || format.includes('esm-bundler')), // 是否可以进行服务器渲染
    __COMPAT__: String(target === 'vue-compat'), // 是否是兼容模式
    __FEATURE_SUSPENSE__: `true`, // 能否使用suspense组件
    __FEATURE_OPTIONS_API__: `true`, // 能否使用options API
    __FEATURE_PROD_DEVTOOLS__: `false`
  },
  watch: { // 对入口文件以及依赖进行监听，如果变化就重新触发打包
    onRebuild(error) {
      // 重新打包时打印打包后的项目路径
      if (!error) console.log(`rebuilt: ${relativeOutfile}`)
    }
  }
}).then(() => {
  // 开启监听时的打包后项目路径
  console.log(`watching: ${relativeOutfile}`)
})
```

<code>scripts/dev.js</code> 脚本主要做了两件事，一个标准化参数，一个执行打包

## rollup 打包

Vue3在打包阶段使用的是rollup，它可以输出体积更小的打包文件以及更好的tree-shaking

```json
{
  "private": true,
  "version": "3.2.45",
  "packageManager": "pnpm@7.1.0",
  "scripts": {
    "build": "node scripts/build.js"
  },
}
```

打包流程在build脚本中

```js
const fs = require('fs-extra') // fs模块，只不过多了一些方法
const path = require('path')
const chalk = require('chalk') // 处理在终端输出的字符串样式
const execa = require('execa') // 运行命令库
const { gzipSync } = require('zlib') // 压缩库
const { compress } = require('brotli') // 压缩库
// allTargets：所有项目名称列表，fuzzyMatchTarget：项目名称列表匹配方法
const { targets: allTargets, fuzzyMatchTarget } = require('./utils')

const args = require('minimist')(process.argv.slice(2)) // 获取命令行参数

const targets = args._ // 需要打包的项目
const formats = args.formats || args.f // 打包版本
const devOnly = args.devOnly || args.d // 是否为开发版本，一般测试配置
const prodOnly = !devOnly && (args.prodOnly || args.p) // 是否为生产版本
const sourceMap = args.sourcemap || args.s // 源码地图
const isRelease = args.release
const buildTypes = args.t || args.types || isRelease // 构建声明文件
const buildAllMatching = args.all || args.a // 是否匹配全部模块，作为fuzzyMatchTarget第二个参数
const commit = execa.sync('git', ['rev-parse', 'HEAD']).stdout.slice(0, 7) // 获取最近commit id的前七位

run()

// 运行打包
async function run() {
  // ...
}

// 打包函数入口
async function buildAll(targets) {
  // ...
}

// 构建打包队列并运行打包
async function runParallel(maxConcurrency, source, iteratorFn) {
  // ...
}

// 打包函数
async function build(target) {
  // ...
}

// 打印所有项目打包体积
function checkAllSizes(targets) {
  // ...
}

// 打印单项目体积
function checkSize(target) {
  // ...
}

// 打印文件体积
function checkFileSize(filePath) {
  // ...
}
```

在执行打包流程前导入一些需要用到的库、工具函数、打包参数，打包参数是根据命令行参数获得，之后正式进入打包流程，首先执行了函数 <code>run</code>

### 打包流程

```js
run()

async function run() {
  if (isRelease) {
    // 删除缓存
    await fs.remove(path.resolve(__dirname, '../node_modules/.rts2_cache'))
  }
  if (!targets.length) {
    // 如果targets没有值则打包全部项目
    await buildAll(allTargets)
    // 打印打包后文件体积
    checkAllSizes(allTargets)
  } else {
    // 如果targets有值则打包部分项目
    await buildAll(fuzzyMatchTarget(targets, buildAllMatching))
    checkAllSizes(fuzzyMatchTarget(targets, buildAllMatching))
  }
}
```

<code>run</code> 函数是打包流程入口
- 根据需要打包项目参数（targets）处理打包情况，如果没有传需要打包的项目则认为打包所有项目
- 调用 <code>buildAll</code> 函数进行对应项目打包
- 调用 <code>checkAllSizes</code> 函数打印打包后文件体积

接下来进入正式的打包流程，函数 <code>buildAll</code> 为入口函数

```js
// 打包函数入口
async function buildAll(targets) {
  // 传入cpu核数，模块列表，打包函数
  await runParallel(require('os').cpus().length, targets, build)
}

// 构建打包队列并运行打包
async function runParallel(maxConcurrency, source, iteratorFn) {
  const ret = []
  const executing = [] // 执行队列
  // 遍历项目列表source构建打包异步队列ret
  for (const item of source) {
    // 利用promise构建异步函数，函数内触发打包函数iteratorFn，传入项目名称，项目列表
    const p = Promise.resolve().then(() => iteratorFn(item, source))
    ret.push(p)

    // 打包的任务大于cpu核数则需要执行队列
    if (maxConcurrency <= source.length) {
      // 将打包函数存入队列，如果执行完毕则删除该项
      const e = p.then(() => executing.splice(executing.indexOf(e), 1))
      executing.push(e)

      if (executing.length >= maxConcurrency) {
        // 如果执行队列等于cpu核数，则等待队列中任何一个打包任务执行完毕
        await Promise.race(executing)
      }
    }
  }
  return Promise.all(ret)
}
```

函数 <code>buildAll</code> 获取当前cpu核数，实际通过 <code>runParallel</code> 函数打包。<code>runParallel</code> 函数逻辑也比较清晰，充分利用cpu核数进行打包，如果打包项目数量小于cpu核数则直接构建队列打包，否则需要控制队列任务，当某任务执行完毕在插入新任务，直到所有打包任务完成

其中打包函数就是 <code>iteratorFn</code> 也就是传入的 <code>build</code> 函数

```js
const formats = args.formats || args.f // 打包版本
const buildTypes = args.t || args.types || isRelease // 构建声明文件
const devOnly = args.devOnly || args.d // 只打包开发版本，一般测试配置
const prodOnly = !devOnly && (args.prodOnly || args.p) // 是否为生产版本
const sourceMap = args.sourcemap || args.s // 源码地图
const commit = execa.sync('git', ['rev-parse', 'HEAD']).stdout.slice(0, 7) // 获取最近commit id的前七位

async function build(target) {
  const pkgDir = path.resolve(`packages/${target}`) // 项目路径
  const pkg = require(`${pkgDir}/package.json`) // 项目配置文件

  // 私有项目不参与打包
  if ((isRelease || !targets.length) && pkg.private) {
    return
  }

  // 没有指定构建格式则删除dist目录
  if (!formats) {
    await fs.remove(`${pkgDir}/dist`)
  }

  // NODE_ENV变量
  const env =
    (pkg.buildOptions && pkg.buildOptions.env) ||
    (devOnly ? 'development' : 'production')

  // 执行rollup -c --environment "COMMIT:true, ..."命令
  await execa(
    'rollup',
    [
      '-c',
      '--environment',
      [
        `COMMIT:${commit}`,
        `NODE_ENV:${env}`,
        `TARGET:${target}`,
        formats ? `FORMATS:${formats}` : ``,
        buildTypes ? `TYPES:true` : ``,
        prodOnly ? `PROD_ONLY:true` : ``,
        sourceMap ? `SOURCE_MAP:true` : ``
      ]
        .filter(Boolean)
        .join(',')
    ],
    { stdio: 'inherit' }
  )

  if (buildTypes && pkg.types) {
    // 如果配置输出声明文件且项目配置输出声明文件路径
    console.log()
    console.log(
      chalk.bold(chalk.yellow(`Rolling up type definitions for ${target}...`))
    )

    // 使用@microsoft/api-extractor库来输出声明文件
    const { Extractor, ExtractorConfig } = require('@microsoft/api-extractor')
    // 获取api-extractor配置
    const extractorConfigPath = path.resolve(pkgDir, `api-extractor.json`)
    // 将配置文件转化成配置实例
    const extractorConfig =
      ExtractorConfig.loadFileAndPrepare(extractorConfigPath)
    // 传入配置生成声明文件
    const extractorResult = Extractor.invoke(extractorConfig, {
      localBuild: true,
      showVerboseMessages: true
    })

    if (extractorResult.succeeded) {
      // 成功输出声明文件
      // 处理项目目录下的types目录下文件
      const typesDir = path.resolve(pkgDir, 'types')
      if (await fs.exists(typesDir)) {
        // 将types目录下每个.d.ts文件读出来写入项目配置中的types路径，一般为dist/项目.d.ts
        const dtsPath = path.resolve(pkgDir, pkg.types)
        const existing = await fs.readFile(dtsPath, 'utf-8')
        const typeFiles = await fs.readdir(typesDir)
        const toAdd = await Promise.all(
          typeFiles.map(file => {
            return fs.readFile(path.resolve(typesDir, file), 'utf-8')
          })
        )
        await fs.writeFile(dtsPath, existing + '\n' + toAdd.join('\n'))
      }
      console.log(
        chalk.bold(chalk.green(`API Extractor completed successfully.`))
      )
    } else {
      // 如果声明文件输出失败程序退出
      console.error(
        `API Extractor completed with ${extractorResult.errorCount} errors` +
          ` and ${extractorResult.warningCount} warnings`
      )
      process.exitCode = 1
    }

    await fs.remove(`${pkgDir}/dist/packages`)
  }
}
```

<code>build</code> 首先执行 <code>rollup</code> 命令并传入对应参数进行打包，后根据 <code>buildTypes && pkg.types</code> 判断是否需要生成声明文件，通过 <code>@microsoft/api-extractor</code> 库生成声明文件，文件名称根据每个项目根目录下的 <code>api-extractor.json</code> 文件配置，一般为 <code>dist/项目名称.d.ts</code>，之后再将项目跟目录下的 <code>types</code> 目录中的文件合并到输出的声明文件中

我们回到最开始的 <code>run</code> 函数，在打包结束后会输出各个项目打包后文件的体积，以及通过 <code>zlib</code> 和 <code>brotli</code> 压缩后文件的体积

```js
// 打印所有项目打包体积
function checkAllSizes(targets) {
  if (devOnly || (formats && !formats.includes('global'))) {
    // 如果是开发版本或者不是全局包
    return
  }
  console.log()
  for (const target of targets) {
    checkSize(target)
  }
  console.log()
}

// 打印单项目体积
function checkSize(target) {
  const pkgDir = path.resolve(`packages/${target}`)
  checkFileSize(`${pkgDir}/dist/${target}.global.prod.js`)
  if (!formats || formats.includes('global-runtime')) {
    // 如果是global-runtime包则需要额外打印体积
    checkFileSize(`${pkgDir}/dist/${target}.runtime.global.prod.js`)
  }
}

// 输出打爆体积
function checkFileSize(filePath) {
  if (!fs.existsSync(filePath)) {
    return
  }
  const file = fs.readFileSync(filePath)
  const minSize = (file.length / 1024).toFixed(2) + 'kb'
  const gzipped = gzipSync(file)
  const gzippedSize = (gzipped.length / 1024).toFixed(2) + 'kb'
  const compressed = compress(file)
  const compressedSize = (compressed.length / 1024).toFixed(2) + 'kb'
  console.log(
    `${chalk.gray(
      chalk.bold(path.basename(filePath))
    )} min:${minSize} / gzip:${gzippedSize} / brotli:${compressedSize}`
  )
}
```

到这里整个打包流程就结束了，总结下就是充分利用cpu的核数进行打包，打包工具是使用rollup打包，之后通过@microsoft/api-extractor库进行输出项目总声明文件，接着将项目根目录下types目录的声明文件合并到项目总声明文件内

### rollup 配置

```js
async function build(target) {
  await execa(
    'rollup',
    [
      '-c',
      '--environment',
      [
        `COMMIT:${commit}`,
        `NODE_ENV:${env}`,
        `TARGET:${target}`,
        formats ? `FORMATS:${formats}` : ``,
        buildTypes ? `TYPES:true` : ``,
        prodOnly ? `PROD_ONLY:true` : ``,
        sourceMap ? `SOURCE_MAP:true` : ``
      ]
        .filter(Boolean)
        .join(',')
    ],
    { stdio: 'inherit' }
  )
}
```

在 <code>build</code> 函数中是调用 <code>rollup</code> 命令进行打包，并传入一些参数，rollup 打包默认会读取项目根目录的 <code>rollup.config.mjs</code> 文件导出结果作为配置，<code>rollup.config.mjs</code> 文件主要做了两件事，我们分别研究

1. 确定打包格式 <code>packageFormats</code>
2. 构建打包配置 <code>packageConfigs</code>

#### 确定打包格式 <code>packageFormats</code>

```js
import { createRequire } from 'module' // node内置模块，这里导入一个创建require的函数

const require = createRequire(import.meta.url) // 创建一个require函数

const packagesDir = path.resolve(__dirname, 'packages') // 获取项目目录路径
const packageDir = path.resolve(packagesDir, process.env.TARGET) // 打包项目路径

const resolve = p => path.resolve(packageDir, p) // 获取路径方法，基于打包项目路径
const pkg = require(resolve(`package.json`)) // 打包项目的package.json
const packageOptions = pkg.buildOptions || {} // 打包项目的打包配置

// 根据优先级标准化打包版本 命令行参数 > 项目配置 > 默认打包版本
const defaultFormats = ['esm-bundler', 'cjs']
const inlineFormats = process.env.FORMATS && process.env.FORMATS.split(',') // 命令行-f参数传入的打包版本
const packageFormats = inlineFormats || packageOptions.formats || defaultFormats
```

构建打包格式 <code>packageFormats</code> 优先考虑命令行 <code>-formats</code> 参数传入的打包格式，其次考虑项目配置文件 <code>package.json</code> 中的 <code>buildOptions.formats</code> 配置，最后考虑默认的打包版本。所以优先级为：命令行参数 > 项目配置 > 默认打包版本

为了获取打包项目的配置文件 <code>package.json</code> 需要做一些准备工作，首先创建 <code>require</code> 函数用来导入文件，下一步获取项目目录路径 <code>packagesDir</code> 和打包项目路径 <code>packageDir</code> ，接着对 <code>path.resolve</code> 函数进行封装，这样不用每次都传入打包项目路径，最后直接通过 <code>require(resolve(`package.json`))</code> 获取打包项目的 <code>package.json</code> 文件内容并获取打包配置 <code>packageOptions</code>

#### 构建打包配置 <code>packageConfigs</code>

构建打包配置需要依赖打包格式 <code>packageFormats</code>，将每一种打包格式都创建一个配置通过 <code>packageConfigs</code> 保存并导出作为 <code>rollup</code> 的打包配置

```ts
// 输出配置表
const outputConfigs = {
  'esm-bundler': { // 构建工具中使用原声模块导入
    file: resolve(`dist/${name}.esm-bundler.js`),
    format: `es`
  },
  'esm-browser': { // 浏览器原生ES模块导入
    file: resolve(`dist/${name}.esm-browser.js`),
    format: `es`
  },
  cjs: { // commonJS模块
    file: resolve(`dist/${name}.cjs.js`),
    format: `cjs`
  },
  global: { // 全局变量版本
    file: resolve(`dist/${name}.global.js`),
    format: `iife`
  },
  // -runtime为运行时包，不带编译器版本
  'esm-bundler-runtime': {
    file: resolve(`dist/${name}.runtime.esm-bundler.js`),
    format: `es`
  },
  'esm-browser-runtime': {
    file: resolve(`dist/${name}.runtime.esm-browser.js`),
    format: 'es'
  },
  'global-runtime': {
    file: resolve(`dist/${name}.runtime.global.js`),
    format: 'iife'
  }
}

const packageConfigs = process.env.PROD_ONLY // 是否只打包生产版本
  ? []
  : packageFormats.map(format => createConfig(format, outputConfigs[format]))

if (process.env.NODE_ENV === 'production') {
  // 生产环境打包逻辑
}

export default packageConfigs
```

<code>process.env.PROD_ONLY</code> 是命令行参数 <code>-devOnly</code>、<code>-prodOnly</code> 控制，[具体逻辑回顾执行打包命令时传入的 PROD_ONLY 参数](/vue3源码/100.项目构建.html#打包流程)，我们先关注生产环境打包，这里 <code>process.env.PROD_ONLY</code> 为 false

<code>packageConfigs</code> 是通过遍历 <code>packageFormats</code> 调用 <code>createConfig</code> 函数构建，调用 <code>createConfig</code> 函数传入每个打包格式以及对应的输出配置

```js
// 构建打包配置
function createConfig(
  format, // 打包格式
  output, // 打包输出配置
  plugins = [] // 打包使用的插件
) {
  // 构建各个配置

  return {
    input: resolve(entryFile), // 入口文件配置
    external, // 不需要打包配置
    plugins: [
      json({
        namedExports: false
      }), // json文件转化为ES模块插件
      tsPlugin, // 转化ts代码为js插件
      createReplacePlugin( // 替换项目内环境变量插件
        isProductionBuild,
        isBundlerESMBuild,
        isBrowserESMBuild,
        (isGlobalBuild || isBrowserESMBuild || isBundlerESMBuild) &&
          !packageOptions.enableNonBrowserBranches,
        isGlobalBuild,
        isNodeBuild,
        isCompatBuild,
        isServerRenderer
      ),
      ...nodePlugins, // commonjs转化es模块插件
      ...plugins // 参数插件
    ],
    output, // 出口配置
    onwarn: (msg, warn) => { // 处理报错信息
      if (!/Circular/.test(msg)) {
        // 报错信息中排除Circular报错
        warn(msg)
      }
    },
    treeshake: {
      moduleSideEffects: false // 删除导入未使用的模块引用语句
    }
  }
}
```

<code>createConfig</code> 函数返回打包配置，内容很多我们围绕返回配置进行拆解，先看 <code>input</code>、<code>external</code>、<code>output</code> 配置的逻辑

```ts
// 构建打包配置
function createConfig(
  format, // 打包格式
  output, // 打包输出配置
  plugins = [] // 打包使用的插件
) {
  const isCompatPackage = pkg.name === '@vue/compat' // 是否是兼容项目
  const isBrowserESMBuild = /esm-browser/.test(format) // 是否为浏览器版本
  const isBundlerESMBuild = /esm-bundler/.test(format) // 是否为构建工具版本
  const isGlobalBuild = /global/.test(format) // 是否为全局变量版本

  // 入口文件配置
  let entryFile = /runtime$/.test(format) ? `src/runtime.ts` : `src/index.ts`
  
  if (isCompatPackage && (isBrowserESMBuild || isBundlerESMBuild)) {
    // 如果是兼容版本，也就是vue-compat仓库，需要更换打包入口
    entryFile = /runtime$/.test(format)
      ? `src/esm-runtime.ts`
      : `src/esm-index.ts`
  }

  let external = [] // 不参与打包配置
  const treeShakenDeps = ['source-map', '@babel/parser', 'estree-walker']

  if (isGlobalBuild || isBrowserESMBuild || isCompatPackage) {
    // 全局版本。浏览器版本、兼容版本，如果没有配置enableNonBrowserBranches则所有依赖都参与打包
    if (!packageOptions.enableNonBrowserBranches) {
      external = treeShakenDeps
    }
  } else {
    external = [
      ...Object.keys(pkg.dependencies || {}), // 生产环境依赖
      ...Object.keys(pkg.peerDependencies || {}), // 依赖描述，peerDependencies 指的是设定依赖兼容最小版本
      ...['path', 'url', 'stream'], // 服务端依赖
      ...treeShakenDeps
    ]
  }

  output.exports = isCompatPackage ? 'auto' : 'named' // 设置导出模式，named为导出多个模块，auto为自动选择导出模式
  output.sourcemap = !!process.env.SOURCE_MAP // 设置源码地图
  output.externalLiveBindings = false // 不会为外部依赖生成支持动态绑定的代码，而是假定外部依赖永远不会改变，当外部依赖存在循环引用时，该选项值为 false 可能会引起问题

  if (isGlobalBuild) {
    // 如果是全局变量版本需要设置全局变量名称
    output.name = packageOptions.name
  }

  return {
    input: resolve(entryFile), // 入口文件配置
    external, // 不需要打包配置
    output, // 出口配置

    // ...
  }
}
```

入口文件 <code>entryFile</code> 是根据打包格式 <code>format</code> 进行判断，首先根据打包格式中是否含有 runtime 字符串判断是否是运行时版本，如果是兼容版本并且在浏览器环境中运行则需要额外逻辑

<code>external</code> 会根据打包版本做区分，部分项目的打包需要排除一些库，其中全局版本、浏览器版本、兼容版本的依赖都将参与打包

输出配置 <code>output</code> 本来是外部传入的参数，内部根据打包格式对输出配置进行拓展

之后看 <code>plugins</code> 配置

```js
import ts from 'rollup-plugin-typescript2' // ts插件，转化ts代码为js
import replace from '@rollup/plugin-replace' // 替换文件内字符串插件
import json from '@rollup/plugin-json' // 将json文件转化为ES模块
import commonJS from '@rollup/plugin-commonjs' // 将commonJS模块转化为ES模块插件，因为rollup仅支持ES模块
import polyfillNode from 'rollup-plugin-polyfill-node' // 如果想在浏览器环境使用一些node模块，则需要该插件
import { nodeResolve } from '@rollup/plugin-node-resolve' // 使用算法快速定位node_modules中的模块

// 构建打包配置
function createConfig(
  format, // 打包格式
  output, // 打包输出配置
  plugins = [] // 打包使用的插件
) {
  // ts插件配置
  const tsPlugin = ts({
    check: process.env.NODE_ENV === 'production' && !hasTSChecked, // 生产环境需要进行ts检查
    tsconfig: path.resolve(__dirname, 'tsconfig.json'), // ts配置文件路径
    cacheRoot: path.resolve(__dirname, 'node_modules/.rts2_cache'), // 缓存路径
    tsconfigOverride: { // 替换ts配置文件配置
      compilerOptions: {
        target: isServerRenderer || isNodeBuild ? 'es2019' : 'es2015', // 如果是服务器渲染或cjs版本则使用es2019标准，否则es2015标准
        sourceMap: output.sourcemap, // 源码地图
        declaration: shouldEmitDeclarations, // ts声明文件
        declarationMap: shouldEmitDeclarations
      },
      exclude: ['**/__tests__', 'test-dts']
    }
  })

  // cjs版本需要将commonjs模块转化为ES模块，因此需要配置额外的插件
  const nodePlugins =
    (format === 'cjs') || packageOptions.enableNonBrowserBranches
      ? [
          commonJS({
            sourceMap: false,
            ignore: cjsIgnores
          }),
          ...(format === 'cjs' ? [] : [polyfillNode()]), // polyfillNode是在浏览器中使用node插件
          nodeResolve()
        ]
      : []
  

  return {
    plugins: [
      json({
        namedExports: false
      }), // json文件转化为ES模块插件
      tsPlugin, // 转化ts代码为js插件
      createReplacePlugin( // 替换项目内环境变量插件
        isProductionBuild,
        isBundlerESMBuild,
        isBrowserESMBuild,
        // isBrowserBuild?
        (isGlobalBuild || isBrowserESMBuild || isBundlerESMBuild) &&
          !packageOptions.enableNonBrowserBranches,
        isGlobalBuild,
        isNodeBuild,
        isCompatBuild,
        isServerRenderer
      ),
      ...nodePlugins, // commonjs转化es模块插件
      ...plugins // 参数插件
    ],

    // ...
  }

// 创建替换环境变量插件
function createReplacePlugin(
  isProduction, // 生产版本
  isBundlerESMBuild, // 构建工具版本
  isBrowserESMBuild, // 浏览器版本
  isBrowserBuild, // 浏览器版本，这里指isGlobalBuild、isBrowserESMBuild、isBundlerESMBuild任意一个版本
  isGlobalBuild, // 全局版本
  isNodeBuild, // cjs版本
  isCompatBuild, // 兼容版本
  isServerRenderer // 服务器版本
) {
  // 构建环境变量
  const replacements = {
    __COMMIT__: `"${process.env.COMMIT}"`, // 当前版本库最新commit id
    __VERSION__: `"${masterVersion}"`, // 主项目版本
    __DEV__: isBundlerESMBuild // 是开发环境
      ? // preserve to be handled by bundlers
        `(process.env.NODE_ENV !== 'production')`
      : // hard coded dev/prod builds
        !isProduction,
    __TEST__: false, // 是测试环境
    __BROWSER__: isBrowserBuild, // 是浏览器环境
    __GLOBAL__: isGlobalBuild, // 是全局环境
    __ESM_BUNDLER__: isBundlerESMBuild, // 是构建工具版本
    __ESM_BROWSER__: isBrowserESMBuild, // 是浏览器版本
    __NODE_JS__: isNodeBuild, // 是cjs版本
    __SSR__: isNodeBuild || isBundlerESMBuild || isServerRenderer, // 是服务器渲染

    // for compiler-sfc browser build inlined deps
    ...(isBrowserESMBuild
      ? {
          'process.env': '({})',
          'process.platform': '""',
          'process.stdout': 'null'
        }
      : {}),

    // 2.x compat build
    __COMPAT__: isCompatBuild, // 是兼容版本

    // feature flags
    __FEATURE_SUSPENSE__: true, // SUSPENSE组件
    __FEATURE_OPTIONS_API__: isBundlerESMBuild ? `__VUE_OPTIONS_API__` : true,
    __FEATURE_PROD_DEVTOOLS__: isBundlerESMBuild
      ? `__VUE_PROD_DEVTOOLS__`
      : false,
    ...(isProduction && isBrowserBuild
      ? {
          'context.onError(': `/*#__PURE__*/ context.onError(`,
          'emitError(': `/*#__PURE__*/ emitError(`,
          'createCompilerError(': `/*#__PURE__*/ createCompilerError(`,
          'createDOMCompilerError(': `/*#__PURE__*/ createDOMCompilerError(`
        }
      : {})
  }
  // 优先使用系统环境变量
  Object.keys(replacements).forEach(key => {
    if (key in process.env) {
      replacements[key] = process.env[key]
    }
  })
  // 打包时替换replacements中对应的环境变量字符串
  return replace({
    // @ts-ignore
    values: replacements,
    // 如果替换的变量为赋值操作则不替换，例如： __COMMIT__ = "aaa" 
    preventAssignment: true
  })
}
```

- <code>@rollup/plugin-json</code>，插件可以将 <code>json</code> 文件内容提取并转化为 ES 模块
- <code>rollup-plugin-typescript2</code>，插件用来转化 ts 文件，转化过程中可以进行语法检查，也可以指定 ts 配置文件
- <code>@rollup/plugin-replace</code>，插件用来匹配并替换代码，这里利用 <code>createReplacePlugin</code> 函数替换代码中的环境变量，例如：__COMPAT__
- <code>@rollup/plugin-commonjs</code>，插件将 commonJS 模块转化成 ES 模块，因为 rollup 默认不兼容 commonJS 模块
- <code>rollup-plugin-polyfill-node</code>，插件可以在浏览器环境中使用部分 node 模块
- <code>@rollup/plugin-node-resolve</code>，插件通过一些算法可以快速的定位 node_modules 中的模块

至此 <code>createConfig</code> 函数就分析完毕，该函数为输出打包配置的核心函数，通过传入的打包格式、输出配置、打包插件来构建出入口配置、插件配置、不需要打包配置。我们分析了开发环境的打包，接下来回到构建打包配置的逻辑，来分析生产环境的打包配置

```js
// 构建打包配置
const packageConfigs = process.env.PROD_ONLY // 只打包生产版本
  ? []
  : packageFormats.map(format => createConfig(format, outputConfigs[format]))

if (process.env.NODE_ENV === 'production') {
  // 如果是生产环境需要输出.prod.js文件
  packageFormats.forEach(format => {
    if (packageOptions.prod === false) {
      return
    }
    if (format === 'cjs') {
      // cjs版本打包配置
      packageConfigs.push(createProductionConfig(format))
    }
    if (/^(global|esm-browser)(-runtime)?/.test(format)) {
      // global(-runtime)、esm-browser(-runtime)版本最小体积打包配置
      packageConfigs.push(createMinifiedConfig(format))
    }
  })
}
```

<code>process.env.PROD_ONLY</code> 表示只打包生产版本，假设它为 true，那么会通过 <code>process.env.NODE_ENV === 'production'</code> 中的逻辑来构建 <code>packageConfigs</code>

通过条件语句可以看出生产环境包只有 <code>cjs</code>、<code>global(-runtime)</code>、<code>esm-browser(-runtime)</code> 五个版本，其中 <code>cjs</code> 的打包配置通过函数 <code>createProductionConfig</code> 构建，非 <code>cjs</code> 的打包配置通过函数 <code>createMinifiedConfig</code> 构建

```js
// 构建生产环境cjs版本打包配置
function createProductionConfig(format) {
  return createConfig(format, {
    file: resolve(`dist/${name}.${format}.prod.js`),
    format: outputConfigs[format].format
  })
}

// 构建代码压缩打包配置
function createMinifiedConfig(format) {
  return createConfig(
    format,
    {
      file: outputConfigs[format].file.replace(/\.js$/, '.prod.js'),
      format: outputConfigs[format].format
    },
    [
      terser({
        module: /^esm/.test(format),
        compress: { // 压缩选项
          ecma: 2015, // 代码语法转换ES版本
          pure_getters: true
        },
        safari10: true
      })
    ]
  )
}
```

两个函数本质还是通过 <code>createConfig</code> 函数构建打包配置，生产环境的 <code>cjs</code> 版本和开发环境比只是将输出文件名改为 <code>dist/${项目名称}.cjs.prod.js</code>

而生产环境的 <code>global(-runtime)</code>、<code>esm-browser(-runtime)</code> 版本和开发环境比不仅将输出的文件名增加了 <code>.prod</code> 后缀，还新增了 <code>terser</code> 用于代码压缩的插件

### 总结

简述打包流程，首先执行 <code>/script/build.js</code> 脚本，该脚本中充分利用cpu多线程打包，之后调用 <code>rollup</code> 命令进行打包，在 <code>rollup</code> 配置中根据打包项目 <code>package.json</code> 的配置进行不同版本的打包

<code>rollup</code> 打包结束后使用 <code>@microsoft/api-extractor</code> 库来生成项目的主声明文件，并将项目中 <code>/types/</code> 目录下的声明文件合并到主声明文件中，最后打印生产环境全局版本的包体积
