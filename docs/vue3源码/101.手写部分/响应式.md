# 响应式

手写 vue 响应式

## 创建一个响应式数据

首先我们有一个副作用函数

```js
const rawObj = {
    text: 'hellow'
};

function effect() {
    document.body.innerText = rawObj.text;
}
```

该函数会更新视图，我们期望在 <code>rawObj</code> 更新时重新触发该函数，这里用 <code>Proxy</code> 实现

<code>Proxy</code> 可以监听到对象的读写，可以在触发读的过程中将副作用函数收集起来，放入一个桶内。在写的时候将桶内的副作用函数取出来执行

```js
const rawObj = {
    text: 'hellow'
};

// 桶
const bucket = [];

const proxyObj = new Proxy(rawObj, {
    get(target, key) {
        // 将副作用放入桶
        bucket.push(effect);
        return target[key];
    },
    set(target, key, newValue) {
        target[key] = newValue;
        // 将桶内副作用执行
        bucket.forEach(e => e());
        return true;
    }
});

function effect() {
    console.log(proxyObj.text);
}

effect();

proxyObj.text = 'word';
```

## 通用副作用函数

上面代码中，副作用函数和代理对象是绑定的，导致每一个代理对象都需要一个副作用函数，我们将这个副作用函数赋给一个统一的变量

```js
const rawObj = {
    text: 'hellow'
};

// 桶
const bucket = [];

// 正在执行的副作用
let activeEffect = null;

const proxyObj = new Proxy(rawObj, {
    get(target, key) {
        // 将副作用放入桶
        activeEffect && bucket.push(activeEffect);
        return target[key];
    },
    set(target, key, newValue) {
        target[key] = newValue;
        // 将桶内副作用执行
        bucket.forEach(e => e());
        return true;
    }
});

// 保存副作用函数并执行
function effect(fn) {
    activeEffect = fn;
    fn();
    activeEffect = null;
}

// 执行副作用
effect(() => {
    console.log(proxyObj.text);
});

proxyObj.text = 'word';
```

我们改造副作用函数，函数会保存传入的副作用并执行它，这样每次代理对象就可以将统一的副作用变量存入桶

## 装副作用的桶

副作用函数中可能会使用多个对象数据，一个对象数据也可能被多个副作用使用，它们是多对多的关系。我们将所有的副作用都放在一个桶里会导致一个数据更新所有副作用函数都将执行，因此我们需要对这个桶进行修改

期望使用这种依赖关系

```txt
（WeakMap）
target
└───（Map）
    key
    └───（Set）
        effect
```

需要对代理对象的 <code>get</code>、<code>set</code> 配置进一步改动

```js
const rawObj = {
    text: 'hellow',
    boolean: true
};

// 桶
const bucket = new WeakMap();

// 正在执行的副作用
let activeEffect = null;

const proxyObj = new Proxy(rawObj, {
    get(target, key) {
        track(target, key);
        return target[key];
    },
    set(target, key, newValue) {
        target[key] = newValue;
        trigger(target, key);
        return true;
    }
});

// 将副作用函数添加到桶中
function track(target, key) {
    // 如果没有当前副作用则返回
    if (!activeEffect) return;

    // 在桶中获取key对应的副作用集合
    if (!bucket.has(target)) {
        bucket.set(target, new Map());
    }
    const keyMap = bucket.get(target);
    if (!keyMap.has(key)) {
        keyMap.set(key, new Set());
    }
    const effects = keyMap.get(key);

    // 将副作用放入桶
    effects.add(activeEffect);
}

// 将桶中的副作用取出来执行
function trigger(target, key) {
    bucket
        .get(target)
        .get(key)
        .forEach(effect => effect());
}

// 保存副作用函数并执行
function effect(fn) {
    activeEffect = fn;
    fn();
    activeEffect = null;
}

effect(() => {
    console.log(proxyObj.text, proxyObj.boolean);
});

proxyObj.text = 'word';
```

提取出 <code>track</code>、<code>trigger</code> 两个函数，分别用于将副作用添加到桶中、将桶中的副作用取出来执行

## 分支情况

副作用函数内可以写 <code>if</code> 语句，当条件判断则一些情况不会触发更新，因此上面代码有个缺陷，我们假设一种情况

```js
// 执行副作用
effect(() => {
    console.log(proxyObj.boolean ? proxyObj.text : null);
});
```

执行副作用，当 <code>proxyObj.boolean === true</code> 时，桶内的结构为

```txt
（WeakMap）
proxyObj
│
├─── boolean
│    └─── effect
│
└─── text
     └─── effect
```

如果此时 <code>proxyObj.boolean === false</code> 时，无论 <code>proxyObj.text</code> 如何变化，将不会影响副作用的执行结果，这会造成额外的性能开销

我们只有在副作用函数执行的时候才能知道，哪些变量是不需要触发副作用更新的，因此需要再副作用函数执行之前，清除相关数据的依赖，也就是清除桶内先关数据的依赖

旧流程：副作用执行 => 收集依赖 => 数据变更 => 副作用执行 => 收集依赖
新流程：副作用执行 => 清除依赖 => 收集依赖 => 数据变更 => 副作用执行 => 清除依赖 => 收集依赖

```js
const rawObj = {
    text: 'hellow',
    boolean: true
};

// 桶
const bucket = new WeakMap();

// 正在执行的副作用
let activeEffect = null;

const proxyObj = new Proxy(rawObj, {
    get(target, key) {
        track(target, key);
        return target[key];
    },
    set(target, key, newValue) {
        target[key] = newValue;
        trigger(target, key);
        return true;
    }
});

// 将副作用函数添加到桶中
function track(target, key) {
    // 如果没有当前副作用则返回
    if (!activeEffect) return;

    // 在桶中获取key对应的副作用集合
    if (!bucket.has(target)) {
        bucket.set(target, new Map());
    }
    const keyMap = bucket.get(target);
    if (!keyMap.has(key)) {
        keyMap.set(key, new Set());
    }
    const effects = keyMap.get(key);

    // 将副作用放入桶
    effects.add(activeEffect);
    // 将数据所依赖的副作用集合收集起来，可以从副作用函数中找到该数据所依赖的副作用列表
    activeEffect.deps.add(effects);
}

// 将桶中的副作用取出来执行
function trigger(target, key) {
    const effects = bucket.get(target).get(key);
    new Set(effects).forEach(effect => effect());
}

// 保存副作用函数并执行
function effect(fn) {
    // 副作用函数
    function effectFn() {
        activeEffect = effectFn;
        // 从deps中剔除此副作用
        cleanup(effectFn);
        fn();
        activeEffect = null;
    }

    // deps收集依赖此副作用数据的副作用列表，用于更新时将此副作用剔除
    effectFn.deps = new Set();
    effectFn();
}

// 从依赖此effect数据的副作用列表中剔除effect
function cleanup(effect) {
    effect.deps.forEach(effects => {
        effects.delete(effect);
    });
}

effect(() => {
    console.log(proxyObj.boolean ? proxyObj.text : null);
});

proxyObj.boolean = false;
proxyObj.text = 'word';
```

1. 首先我们改动副作用函数 <code>effectFn</code>，挂载 <code>deps</code> 属性，用于收集依赖当前副作用数据的副作用集合。<code>cleanup</code> 函数将当前副作用函数，从依赖中剔除
2. 在收集依赖过程中，将该数据对应的副作用集合存入 <code>activeEffect.deps</code>
3. 更新依赖时需要将 <code>bucket.get(target).get(key)</code> 重新赋值，否则这里会无线循环

<br />

> 副作用函数 effectFn 的 deps 属性记录：[proxyObj.boolean 的副作用集合, proxyObj.text 的副作用集合]，更新前将 proxyObj.boolean 和 proxyObj.text 的副作用集合中剔除当前副作用

<br />

> trigger 函数中执行副作用会导致无线循环，是因为使用 forEach 的原因
> 在执行副作用时需要清除桶内对应副作用，接着 track 会在将副作用收集到桶中，由于 trigger 中和执行副作用前清除操作的是同一个副作用列表，就会导致 forEach 不停的进行迭代
> 也就是说 trigger 会：执行副作用 1 => 清除副作用 1 => 重新添加副作用 2 => 执行副作用 2 => 清除副作用 2 => 重新添加副作用 3 => ...

## effect 嵌套

副作用函数内可能会嵌套若干副作用函数，就像组件内使用组件，如：

```js
effect(() => {
    effect(() => {
        console.log('effect2', proxyObj.text);
    });
    console.log('effect1', proxyObj.boolean);
});

proxyObj.boolean = false;
```

如果代码不做修改，那么在更新 <code>proxyObj.boolean</code> 的时结果如下：

```txt
effect2 hellow
effect1 true
```

只打印了初始化的结果，更新 <code>proxyObj.boolean</code> 时却不触发副作用了

我们看下副作用函数执行规则：

```js
// 副作用函数
function effectFn() {
    activeEffect = effectFn;
    // 从deps中剔除此副作用
    cleanup(effectFn);
    // 执行真正的副作用
    fn();
    activeEffect = null;
}
```

由于使用 activeEffect 只能存储一个副作用，每次副作用执行完毕都赋值为 null，这就导致了 effect2 在执行完毕后将 activeEffect 置为 null，接着执行 effect1 时就判断了没有副作用

应该使用栈结构存储当前副作用，我们重构 activeEffect 为 effectStack

```js
// 正在执行的副作用
let effectStack = [];

// 保存副作用函数并执行
function effect(fn) {
    // 副作用函数
    function effectFn() {
        // 入栈
        effectStack.push(effectFn);
        // 从deps中剔除此副作用
        cleanup(effectFn);
        // 执行真正的副作用
        fn();
        // 出栈
        effectStack.pop();
    }

    // deps收集依赖此副作用数据的副作用列表，用于更新时将此副作用剔除
    effectFn.deps = new Set();
    effectFn();
}

// 将副作用函数添加到桶中
function track(target, key) {
    // 如果没有当前副作用则返回
    if (!effectStack.length) return;

    // 在桶中获取key对应的副作用集合
    if (!bucket.has(target)) {
        bucket.set(target, new Map());
    }
    const keyMap = bucket.get(target);
    if (!keyMap.has(key)) {
        keyMap.set(key, new Set());
    }
    const effects = keyMap.get(key);

    // 将副作用放入桶
    const activeEffect = effectStack[effectStack.length - 1];
    effects.add(activeEffect);
    // 将数据所依赖的副作用集合收集起来，可以从副作用函数中找到该数据所依赖的副作用列表
    activeEffect.deps.add(effects);
}
```

1. 对 effect 函数进行改造，执行副作用前将当前副作用入栈，执行后出栈
2. 对 track 函数收集副作用的部分改造，取栈末尾的副作用函数，就是当前副作用

继续使用上面的例子执行，修改 <code>proxyObj.boolean</code> 就会重新触发副作用函数

```txt
effect2 hellow
effect1 true
effect2 hellow
effect1 false
```

## 避免无限循环

如果在副作用函数中读取一个数据，同时又操作它，那么会出现无限递归的情况

```js
effect(() => {
    console.log('effect', proxyObj.num++);
});
```

代码会报错栈溢出，我们来分析下 <code>proxyObj.num++</code> 这段代码相当于 <code>proxyObj.num = proxyObj.num + 1</code>（不考虑增量运算符在数据前后的问题

当副作用执行，会先通过 <code>track</code> 将副作用收集到桶中，紧接着触发数据更新调用 <code>trigger</code> 函数更新当前副作用，这样又回到开始的逻辑以此类推

此情况出现的原因是 <code>trigger</code> 中执行的副作用和当前副作用为同一个函数，我们只需要避免这种情况即可

```js
// 将桶中的副作用取出来执行
function trigger(target, key) {
    const effects = bucket.get(target).get(key);
    new Set(effects).forEach(effect => {
        // 如果即将执行的副作用为当前副作用，则跳过
        if (effect === effectStack[effectStack.length - 1]) return;

        effect();
    });
}
```

## 调度器 scheduler

可调度性是响应式系统重要的特性，指的是在 <code>trigger</code> 触发副作用时，可以选择触发的时机、次数、方式

```js
effect(() => {
    console.log('effect', proxyObj.num);
});

proxyObj.num++;

console.log('同步代码执行完毕');
```

如这段代码执行时机为：

```txt
effect 0 // 初始化副作用打印
effect 1 // 更新proxyObj.num时打印
同步代码执行完毕 // 代码执行完毕打印
```

如果有需求要将触发 <code>proxyObj.num</code> 更新时的副作用改为异步触发，则打印结果为：

```txt
effect 0 // 初始化副作用打印
同步代码执行完毕 // 代码执行完毕打印
effect 1 // 更新proxyObj.num时打印
```

那么我们就需要让副作用函数支持调度

```js
effect(
    () => {
        console.log('effect', proxyObj.num);
    },
    {
        // 调度器
        scheduler(effect) {
            console.log(effect);
        }
    }
);
```

首先在函数 <code>effect</code> 增加第二个参数为 options

```js
// 保存副作用函数并执行
function effect(fn, options = {}) {
    // 副作用函数
    function effectFn() {
        // 入栈
        effectStack.push(effectFn);
        // 从deps中剔除此副作用
        cleanup(effectFn);
        // 执行真正的副作用
        fn();
        // 出栈
        effectStack.pop();
    }

    // deps收集依赖此副作用数据的副作用列表，用于更新时将此副作用剔除
    effectFn.deps = new Set();
    // 挂载副作用配置
    effectFn.options = options;

    effectFn();
}
```

接着将 options 参数挂载到，副作用函数 <code>effectFn</code> 上

```js
// 将桶中的副作用取出来执行
function trigger(target, key) {
    const effects = bucket.get(target).get(key);
    new Set(effects).forEach(effect => {
        // 如果即将执行的副作用为当前副作用，则跳过
        if (effect === effectStack[effectStack.length - 1]) return;

        if (effect.options.scheduler) {
            // 如果有调度器配置，则调用调度器
            effect.options.scheduler(effect);
        } else {
            // 否则直接执行副作用
            effect();
        }
    });
}
```

最后在 <code>trigger</code> 执行副作用函数之前判断是否配置了调度器，并将副作用函数传入。到这里副作用函数就支持调度了，我们使用调度器来完成最开始的例子

```js
effect(
    () => {
        console.log('effect', proxyObj.num);
    },
    {
        // 调度器
        scheduler(effect) {
            Promise.resolve().then(effect);
        }
    }
);

proxyObj.num++;

console.log('同步代码执行完毕');
```

这样就通过调度器实现了异步执行副作用函数

```txt
effect 0
同步代码执行完毕
effect 1
```

## 无效更新

在修改数据时可能会出现以下情况

```js
effect(() => {
    console.log('effect', proxyObj.text, proxyObj.boolean);
});

proxyObj.text = 'word';
proxyObj.boolean = false;
```

此时我们看下打印：

```txt
effect hellow true // 首次触发
effect word true // 更新proxyObj.text触发
effect word false // 更新proxyObj.boolean触发
```

可以看出我们更新了两个数据，副作用函数触发了两次，实时上更新 <code>proxyObj.text</code> 数据只是中间状态，直到 <code>proxyObj.boolean</code> 更新完毕后才是最终结果，那么就存在第一次更新是无效的

利用上一节增加的调度器配置，我们在副作用执行的时候塞进任务队列，将队列去重后执行，这样实现了多次修改一次更新，代码上改动如下：

```js
// 任务队列
const jobQueue = new Set();
// 任务队列正在执行
let isFlushing = false;

// 执行jobQueue队列
function flushJob() {
    // 如果队列正在执行则返回
    if (isFlushing) return;
    isFlushing = true;

    const p = Promise.resolve();
    p.then(() => {
        // 异步微队列中执行任务列表
        jobQueue.forEach(job => job());
    }).finally(() => {
        // 执行完毕后将任务列表清空
        jobQueue.clear();
        isFlushing = false;
    });
}
```

首先创建一个任务队列 <code>jobQueue</code>，用来存放即将被执行的副作用函数

后在 <code>flushJob</code> 函数中执行该队列，判断任务队列执行标识 <code>isFlushing</code>，防止任务队列反复执行，最后在异步中执行任务队列

这样代码改动就完成了，我们看下调度器中如何使用：

```js
effect(
    () => {
        console.log('effect', proxyObj.text, proxyObj.boolean);
    },
    {
        // 调度器
        scheduler(effect) {
            // 加入任务队列
            jobQueue.add(effect);
            // 执行任务队列
            flushJob();
        }
    }
);

proxyObj.text = 'word';
proxyObj.boolean = false;
```

我们只需要在调度器中将副作用函数加入任务队列，紧接着执行即可

由于加入的行为是同步逻辑，而执行队列则是异步逻辑，所以会将所有的副作用都加入任务队列后进入异步执行任务队列

## lazy 和计算属性 computed

计算属性是在访问的时候执行的，因此我们需要实现副作用函数延迟执行

```js
// 保存副作用函数并执行
function effect(fn, options = {}) {
    // 副作用函数
    function effectFn() {
        // 入栈
        effectStack.push(effectFn);
        // 从deps中剔除此副作用
        cleanup(effectFn);
        // 新增：执行真正的副作用，将结果记录返回
        const result = fn();
        // 出栈
        effectStack.pop();
        // 新增
        return result;
    }

    // deps收集依赖此副作用数据的副作用列表，用于更新时将此副作用剔除
    effectFn.deps = new Set();
    // 挂载副作用配置
    effectFn.options = options;

    // 新增：非懒执行
    if (!options.lazy) {
        effectFn();
    }

    // 新增
    return effectFn;
}

const myEffectFn = effect(() => console.log(proxyObj.num), {
    lazy: true
});

myEffectFn();
```

增加 effect 函数第二个参数配置 lazy，在函数内部进行判断 effectFn 是否执行，并最后将 effectFn 函数返回，这样就实现了副作用函数延迟执行

effectFn 函数内将真正副作用函数返回值返回，为计算属性做准备

只做了懒加载还远远不够，我们希望计算属性的调用方式如下：

```js
const computedNum = computed(() => proxyObj.num * 2);

console.log(computedNum.value);
console.log(computedNum.value);
console.log(computedNum.value);
```

因此我们需要对 effect 函数进行二次封装

```js
// 计算属性
function computed(getter) {
    const effectFn = effect(getter, {
        lazy: true
    });

    return {
        get value() {
            return effectFn();
        }
    };
}
```

这样使用计算属性是没有缓存的，也就是说每次访问 <code>computedNum.value</code> 的时候都会触发副作用函数，即使 <code>computedNum.value</code> 没有改变。我们可以增加缓存机制进一步提高性能

```js
// 计算属性
function computed(getter) {
    // 数据变化开关
    let isChanged = true;

    const effectFn = effect(getter, {
        lazy: true,
        scheduler() {
            isChanged = true;
        }
    });

    // 缓存
    let cache = null;

    const obj = {
        get value() {
            if (isChanged) {
                isChanged = false;
                cache = effectFn();
            }

            return cache;
        }
    };

    return obj;
}
```

首先使用 isChanged 判断是否需要更新，更新后存入缓存 cache，并将开关 isChanged 关闭。当 getter 函数内的数据变化会触发 effect，我们利用调度器 scheduler 重新把开关 isChanged 打开，这样下次访问计算属性就可以重新计算了

我们来测试一下计算属性：

```js
const computedNum = computed(() => proxyObj.num);

effect(() => {
    console.log('computedNum.value更新了', computedNum.value);
});

proxyObj.num++;
```

发现只有副作用函数初始化的时候执行了，当 <code>proxyObj.num</code> 数据更新时却没有执行。这是因为副作用内的计算属性并没有调用 track 函数收集依赖，更新时也没有调用 trigger 函数更新依赖

```js
// 计算属性
function computed(getter) {
    // 数据变化开关
    let isChanged = true;

    const effectFn = effect(getter, {
        lazy: true,
        scheduler() {
            isChanged = true;
            // 新增，在计算属性更新后立即触发依赖
            trigger(obj, 'value');
        }
    });

    // 缓存
    let cache = null;

    const obj = {
        get value() {
            if (isChanged) {
                isChanged = false;
                cache = effectFn();
            }

            // 新增，在访问时收集计算属性依赖
            track(obj, 'value');
            return cache;
        }
    };

    return obj;
}
```

我们在计算属性的访问和更新处分别加上了 track 和 trigger 用于收集依赖以及更新依赖，这样在调用刚才的例子就是期望的效果

```txt
computedNum.value更新了 0
computedNum.value更新了 1
```

## 监听属性 watch

我们期望使用监听属性的方式如下：

```js
watch(
    () => proxyObj.num,
    (newValue, oldValue) => {
        console.log('proxyObj.num更新了', oldValue, newValue);
    }
);

proxyObj.num++;
proxyObj.num++;
proxyObj.num++;
```

我们创建 watch 函数来实现监听功能

```js
// 监听属性
function watch(source, callback) {
    let oldValue = null;
    let newValue = null;

    // 监听副作用函数
    function watchEffect() {
        // 监听数据
        let watchData = null;

        if (typeof source === 'function') {
            watchData = source();
        } else {
            watchData = source;
        }

        return watchData;
    }

    const effectFn = effect(watchEffect, {
        lazy: true,
        scheduler() {
            oldValue = newValue;
            newValue = effectFn();
            callback(newValue, oldValue);
        }
    });

    // 首次手动调用收集依赖
    effectFn();
}
```

我们创建一个监听属性副作用函数，watchEffect 函数会访问需要监听的属性从而收集依赖 watchEffect。在数据更新时获取新旧数据并调用 callback 函数将其传入。这样就完成了监听属性的雏形，调用上面的例子看下结果：

```txt
proxyObj.num更新了 null 1
proxyObj.num更新了 1 2
proxyObj.num更新了 2 3
```

### 深度监听 deep

我们知道监听属性可以进行深度监听，如果我们传入的 getter 返回一个对象则监听属性就会失效。我们需要对 watchEffect 函数进行改动，使监听属性可以深度监听对象

```js
// 监听属性
function watch(source, callback, options = {}) {
    let oldValue = null;
    let newValue = null;

    // 监听副作用函数
    function watchEffect() {
        // 监听数据
        let watchData = null;

        if (typeof source === 'function') {
            watchData = source();
        } else {
            watchData = source;
        }

        // 新增：访问对象中所有属性
        if (options.deep) {
            traverse(watchData);
        }

        return watchData;
    }

    effect(watchEffect, {
        scheduler(effect) {
            oldValue = newValue;
            newValue = effect();
            callback(newValue, oldValue);
        }
    });
}

// 新增：递归获取对象每一个属性
function traverse(node, seen = new Set()) {
    const type = Object.prototype.toString.call(node);

    if (['[object Array]', '[object Object]'].includes(type) && !seen.has(node)) {
        seen.add(node);
        for (const key in node) {
            traverse(node[key], seen);
        }
    }
}
```

在监听属性 watch 方法中增加第三个参数 options，判断 options.deep 属性是否需要深度监听该属性，如果需要则使用 traverse 方法来访问监听对象中每一个属性值，其中 seen 参数用来判断某个属性是否已经读取，避免循环引用。

> 调用 traverse 方法访问属性值是在副作用函数中进行的，因此该对象内所有的方法都已经收集了该副作用做为依赖，在触发更新时就会执行该副作用

### 立即触发 immediate

监听属性可以增加 immediate 配置来使监听属性在初始化的时触发，我们需要对 watch 方法做修改

```js
// 监听属性
function watch(source, callback, options = {}) {
    let oldValue = null;
    let newValue = null;

    // 监听副作用函数
    function watchEffect() {
        // 监听数据
        let watchData = null;

        if (typeof source === 'function') {
            watchData = source();
        } else {
            watchData = source;
        }

        if (options.deep) {
            traverse(watchData);
        }

        return watchData;
    }

    // 新增：触发回调任务
    function job() {
        oldValue = newValue;
        newValue = effectFn();
        callback(newValue, oldValue);
    }

    const effectFn = effect(watchEffect, {
        lazy: true,
        scheduler: job
    });

    // 新增：初始化是否触发回调
    if (options.immediate) {
        // 触发回调
        job();
    } else {
        // 首次手动调用收集依赖
        effectFn();
    }
}
```

我们将 scheduler 提取出名为 job 的函数，该函数用于触发回调，在判断 options.immediate 即是否配置了首次触发回调，来判断直接触发回调 job 还是触发 effectFn 收集依赖

> job 函数中使用了 effectFn 副作用来获取最新的值，因此首次触发回调不需要在调用 effectFn 函数来收集依赖

### 执行时机 flush

vue3 中增加了 options.flush 配置，可以在异步中触发监听属性更新的回调，可以用于 DOM 更新结束后触发回调

```js
// 监听属性
function watch(source, callback, options = {}) {
    let oldValue = null;
    let newValue = null;

    // 监听副作用函数
    function watchEffect() {
        // 监听数据
        let watchData = null;

        if (typeof source === 'function') {
            watchData = source();
        } else {
            watchData = source;
        }

        if (options.deep) {
            traverse(watchData);
        }

        return watchData;
    }

    // 触发回调任务
    function job() {
        oldValue = newValue;
        newValue = effectFn();
        callback(newValue, oldValue);
    }

    const effectFn = effect(watchEffect, {
        lazy: true,
        scheduler() {
            // 新增：异步调用job
            if (options.flush === 'post') {
                Promise.resolve().then(job);
            } else {
                job();
            }
        }
    });

    if (options.immediate) {
        // 触发回调
        job();
    } else {
        // 首次手动调用收集依赖
        effectFn();
    }
}
```

在 scheduler 中判断 options.flush 配置是否在异步触发 job 函数即可

### 过期副作用

我们在监听属性中肯能会请求接口，如果一个监听属性被调用两次，那么就会有两个异步接口发出，由于接口响应的顺序无法保证，因此可能出现混乱，如下：

```js
watch(
    () => proxyObj.num,
    (newValue, oldValue) => {
        // 模拟异步接口请求3s-5s打印
        setTimeout(() => {
            console.log('proxyObj.num更新了', oldValue, newValue);
        }, Math.random() * 3000 + 2000);
    }
);

proxyObj.num++;
proxyObj.num++;
```

这段代码模拟异步接口请求，在 3s-5s 后打印值来模拟接口响应，多次执行代码发现打印结果不一样

```js
proxyObj.num更新了 null 1
proxyObj.num更新了 1 2
// 可能是上面也可能是下面的结果
proxyObj.num更新了 1 2
proxyObj.num更新了 null 1
```

为了避免这种情况我们需要一个注册过期副作用的函数，作为监听函数第三个参数

```js
watch(
    () => proxyObj.num,
    (newValue, oldValue, onInvalidate) => {
        let expired = false;
        onInvalidate(() => {
            expired = true;
        });

        // 模拟异步接口请求3s-5s打印
        setTimeout(() => {
            !expired && console.log('proxyObj.num更新了', oldValue, newValue);
        }, Math.random() * 3000 + 2000);
    }
);

proxyObj.num++;
proxyObj.num++;
```

当多次触发监听函数时，通过 onInvalidate 函数注册一个过期函数，当该监听函数过期后，就会触发过期函数，此时就只会打印最后一次更新。我们还需改动 watch 方法

```js
// 监听属性
function watch(source, callback, options = {}) {
    let oldValue = null;
    let newValue = null;
    // 新增：清除监听函数
    let cleanup = null;

    // 监听副作用函数
    function watchEffect() {
        // 监听数据
        let watchData = null;

        if (typeof source === 'function') {
            watchData = source();
        } else {
            watchData = source;
        }

        if (options.deep) {
            traverse(watchData);
        }

        return watchData;
    }

    // 触发回调任务
    function job() {
        // 新增：清除函数有值则调用清除函数
        cleanup && cleanup();
        oldValue = newValue;
        newValue = effectFn();
        // 新增：赋值cleanup函数
        callback(newValue, oldValue, fn => (cleanup = fn));
    }

    const effectFn = effect(watchEffect, {
        lazy: true,
        scheduler() {
            if (options.flush === 'post') {
                Promise.resolve().then(job);
            } else {
                job();
            }
        }
    });

    if (options.immediate) {
        // 触发回调
        job();
    } else {
        // 首次手动调用收集依赖
        effectFn();
    }
}
```

方法内新增 cleanup 用来缓存过期函数，在执行 job 任务时调用 cleanup 缓存的过期函数，最后在调用 callback 时传入第三个参数为 cleanup 赋值函数

第一次更新会注册一个过期函数在 cleanup 中，当第二次更新时就会调用第一次注册的过期函数，从而清除第一次更新的监听函数，这样就可以保证多次更新时，保证最后一次是有效的

## proxy 和 Reflect

首先介绍一下 Reflect，这是一个 js 全局的工具类，提供了一些方法

```js
Reflect.get(obj, key);
Reflect.set(obj, key, newValue);

new Proxy(obj, {
    get(target, key) {
        return target[key];
    },
    set(target, key, newValue) {
        target[key] = newValue;
        return true;
    }
});
```

Reflect 上提供了一些方法和 porxy 的第二个参数配置是一一对应的，其作用也是一样的。但是 Reflect 上的方法可以多传入一个参数 receiver

```js
const obj = {
    get foo() {
        return this.bar;
    },
    bar: 1
};

Reflect.get(obj, 'bar', { bar: 2 }); // 2
```

可以看到传入了 receiver 参数后获取的值就变成了 2，可以认为 receiver 参数会改变正在执行的 Reflect 方法中传入 obj 的 this。到这里就算了解了 Reflect

了解 Reflect 是为了解决某个情况下的问题，如下：

```js
const rawObj = {
    get foo() {
        return this.bar;
    },
    bar: 1
};

const proxyObj = new Proxy(rawObj, {
    get(target, key) {
        track(target, key);
        return target[key];
    },
    set(target, key, newValue) {
        target[key] = newValue;
        trigger(target, key);
        return true;
    }
});

effect(() => {
    console.log(proxyObj.foo);
});

proxyObj.bar++;
```

理想状态是 proxyObj.bar 触发更新时副作用会执行，实际情况是触发更新后副作用未执行。我们来梳理下情况，当副作用首次触发时访问了 proxyObj.foo，因此会触发 proxyObj 的 getter 函数

```js
const proxyObj = new Proxy(rawObj, {
    get(target, key) {
        track(target, key);
        return target[key];
    }
    // ...
});
```

getter 函数中访问了 rawObj.foo，而 rawObj.foo 访问了 rawObj.bar。rawObj.bar 不是一个代理对象，因此并不会进行收集依赖操作

> 这里要搞清楚 getter 中的 target 参数是 rawObj 未代理的对象

因此，问题的核心在于：代理对象 foo ==访问==> 真实对象 foo ==通过 this（真实对象）访问==> 真实对象 bar，我们只需要将这个 this 指向代理对象即可

```js
const proxyObj = new Proxy(rawObj, {
    get(target, key, receiver) {
        track(target, key);
        return Reflect.get(target, key, receiver);
    }
    // ...
});
```

getter 函数提供了第三个参数 receiver，该参数就是代理对象 proxyObj，这样每次访问真实对象时 this 都指向代理对象，因此问题就解决了

## 合理代理对象数据

我们之前使用 proxy 代理对象只使用了简单的 getter 和 setter 配置进行收集依赖以及派发更新，没有考虑到删除以及其他访问对象的方式（如：in、for in）

接下来我们完善代理对象 proxy 的配置，在完善 proxy 配置之前，我们需要对 proxy 的第二个参数 handler 以及对象操作有所了解，我们在操作对象时会调用对象内置的方法，例如：obj.foo，就会调用 obj 上的 \[[get]] 方法，这些方法在 proxy 的 handler 参数中都有对应的配置

| 对象内部方法           | 对应 proxy 配置          | 解释               |
| ---------------------- | ------------------------ | ------------------ |
| \[[GetPrototypeOf]]    | getPrototypeOf           | 获取对象原型       |
| \[[SetPrototypeOf]]    | setPrototypeOf           | 设置对象原型       |
| \[[IsExtensible]]      | isExtensible             | 返回对象是否可扩展 |
| \[[PreventExtensions]] | preventExtensions        | 使对象不可拓展     |
| \[[GetOwnProperty]]    | getOwnPropertyDescriptor | 返回对象描述符     |
| \[[DefineOwnProperty]] | defineProperty           | 在对象上定义新属性 |
| \[[HasProperty]]       | has                      | 使用 in 关键字     |
| \[[Get]]               | get                      | 访问对象属性       |
| \[[Set]]               | set                      | 修改对象属性       |
| \[[Delete]]            | deleteProperty           | 删除对象属性       |
| \[[OwnPropertyKeys]]   | ownKeys                  | 获取对象 key 列表  |
| \[[Call]]              | apply                    | 函数对象执行       |
| \[[Construct]]         | construct                | new 关键字调用函数 |

### 区别对象更新类型

目前访问对象的方式有以下几种：

```js
effect(() => {
    // 通过属性访问
    obj.foo;

    // 通过in关键字访问
    'foo' in obj;

    // 使用for in访问
    for (const key in obj) {
    }
    // 使用Object.keys()
    Object.keys(obj);
});
```

首先处理 in 关键字，通过上面表格知道使用 in 关键字会调用对象内部方法 \[[HasProperty]]，对应 proxy 配置就是 has

```js
const proxyObj = new Proxy(rawObj, {
    // ...

    has(target, key) {
        track(target, key);
        return Reflect.has(target, key);
    }
});
```

配置 has，并在内部收集依赖即可

之后是 for in 关键字，该关键字会调用对象内部方法 \[[OwnPropertyKeys]] 来获取所有属性，之后在进行遍历，因此我们需要在 proxy 中配置 ownKeys

> for in 和 Object.keys 方法处理逻辑一样

```js
// 迭代器的key，用于依赖收集
const ITERATE_KEY = Symbol('ITERATE_KEY');

const proxyObj = new Proxy(rawObj, {
    // ...

    ownKeys(target) {
        track(target, ITERATE_KEY);
        return Reflect.ownKeys(target);
    }
});
```

\[[OwnPropertyKeys]] 方法是用来获取对象属性的，因此 ownKeys 配置只会有一个 target 参数，我们收集依赖的时候需要一个 key 来存储依赖，这里我们创建一个 ITERATE_KEY 全局变量作为收集迭代器依赖的 key。到这里我们成功的收集了迭代器的依赖，还需要在派发更新时触发 ITERATE_KEY 对应的依赖

```js
// 将桶中的副作用取出来执行
function trigger(target, key) {
    // 副作用队列
    const effects = [];

    const targetMap = bucket.get(target);

    // 新增：将依赖key的副作用加入队列
    targetMap.has(key) && effects.push(...targetMap.get(key));

    // 新增：将迭代器key的副作用加入队列
    targetMap.has(ITERATE_KEY) && effects.push(...targetMap.get(ITERATE_KEY));

    new Set(effects).forEach(effect => {
        // 如果即将执行的副作用为当前副作用，则跳过
        if (effect === effectStack[effectStack.length - 1]) return;

        if (effect.options.scheduler) {
            // 如果有调度器配置，则调用调度器
            effect.options.scheduler(effect);
        } else {
            // 否则直接执行副作用
            effect();
        }
    });
}
```

我们把对应的副作用函数从 bucket 中取出并加入 effects 副作用队列等待执行

目前还会有一些多余的性能开销，如果只是修改了对象中已存在的属性，那么也会触发 ITERATE_KEY 对应的副作用函数。修改已存在属性并不会改变数据结构，因此副作用不应该在次执行，我们需要对 trigger 做一些修改

```js
// 将桶中的副作用取出来执行
function trigger(target, key, type) {
    // 副作用队列
    const effects = new Set();

    const targetMap = bucket.get(target);

    // 将依赖key的副作用加入队列
    targetMap.has(key) && targetMap.get(key).forEach(effect => effects.add(effect));

    // 新增：将迭代器key的副作用加入队列
    if (type === 'ADD') {
        // 只有在增加的时候才需要触发遍历相关副作用
        targetMap.has(ITERATE_KEY) && targetMap.get(ITERATE_KEY).forEach(effect => effects.add(effect));
    }

    // 赋值一个新的Set进行遍历，不然forEach会无限循环
    new Set(effects).forEach(effect => {
        // 如果即将执行的副作用为当前副作用，则跳过
        if (effect === effectStack[effectStack.length - 1]) return;

        if (effect.options.scheduler) {
            // 如果有调度器配置，则调用调度器
            effect.options.scheduler(effect);
        } else {
            // 否则直接执行副作用
            effect();
        }
    });
}
```

trigger 函数增加第三个参数 type，用来区分当前数据是增加、删除、修改，我们还需要再 proxy.set 配置中将这个参数传入

```js
const proxyObj = new Proxy(rawObj, {
    // ...

    set(target, key, newValue) {
        // 新增：是否存在该属性
        const hasKey = target.hasOwnProperty(key);
        target[key] = newValue;
        trigger(target, key, hasKey ? 'SET' : 'ADD');
        return true;
    }

    // ...
});
```

这样在修改已有属性时， ITERATE_KEY 对应的副作用就不会加入队列执行

### 删除对象属性

我们按照上面的表可以找到删除会触发 proxy 的 deleteProperty 配置，我们加上该配置

```js
const proxyObj = new Proxy(rawObj, {
    // ...

    deleteProperty(target, key) {
        // 是否存在该属性
        const hasKey = target.hasOwnProperty(key);
        // 判断该属性存在，且删除成功
        const res = hasKey && Reflect.deleteProperty(target, key);
        // 触发副作用
        if (res) {
            trigger(target, key, 'DELETE');
        }
        return res;
    }
});
```

属性被删除后，上面所说的 for in 这个副作用是需要重新触发的，因为修改了数据结构，因此我们需要让 trigger 函数中加入新的类型 "DELETE"

```js
// 将桶中的副作用取出来执行
function trigger(target, key, type) {
    // 副作用队列
    const effects = new Set();

    const targetMap = bucket.get(target);

    // 将依赖key的副作用加入队列
    targetMap.has(key) && targetMap.get(key).forEach(effect => effects.add(effect));

    // 将迭代器key的副作用加入队列
    if (type === 'ADD' || type === 'DELETE') {
        // 新增：只有在增加和删除的时候才需要触发遍历相关副作用
        targetMap.has(ITERATE_KEY) && targetMap.get(ITERATE_KEY).forEach(effect => effects.add(effect));
    }

    // 赋值一个新的Set进行遍历，不然forEach会无限循环
    new Set(effects).forEach(effect => {
        // 如果即将执行的副作用为当前副作用，则跳过
        if (effect === effectStack[effectStack.length - 1]) return;

        if (effect.options.scheduler) {
            // 如果有调度器配置，则调用调度器
            effect.options.scheduler(effect);
        } else {
            // 否则直接执行副作用
            effect();
        }
    });
}
```

只需要在触发 ITERATE_KEY 前多一个判断即可

这样我们就完善了使用 in 关键字时如何收集依赖，使用 for in 和删除属性的时候如何收集以及触发依赖

## 封装 Proxy 配置

如果我们需要创建多个响应式数据，那么则需要写多个 proxy 配置，我们把这些配置封装成一个函数，使其返回响应式对象

```js
// 新增：响应式数据
function reactive(obj) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            track(target, key);
            return Reflect.get(target, key, receiver);
        },
        set(target, key, newValue) {
            // 是否存在该属性
            const hasKey = target.hasOwnProperty(key);
            target[key] = newValue;
            trigger(target, key, hasKey ? 'SET' : 'ADD');
            return true;
        },
        has(target, key) {
            track(target, key);
            return Reflect.has(target, key);
        },
        ownKeys(target) {
            track(target, ITERATE_KEY);
            return Reflect.ownKeys(target);
        },
        deleteProperty(target, key) {
            // 是否存在该属性
            const hasKey = target.hasOwnProperty(key);
            const res = hasKey && Reflect.deleteProperty(target, key);
            // 删除成功在触发副作用
            if (res) {
                trigger(target, key, 'DELETE');
            }
            return res;
        }
    });
}

const proxyObj = reactive({
    a: 1,
    b: 2
});
```

这样我们在创建响应式数据就更加方便

## 合理触发副作用

在数据更新触发副作用时有一些场景可以优化，比如：数据更新了相同的值、原型继承等

### 数据更新了相同的值

```js
const rawObj = {
    a: 1
};

const proxyObj = reactive(rawObj);

effect(() => {
    console.log(proxyObj.a);
});

proxyObj.a = 1;
```

例如这个情况，proxyObj.a 更新了相同的值目前也会导致副作用触发

```js
// 响应式数据
function reactive(obj) {
    return new Proxy(obj, {
        // ...

        set(target, key, newValue) {
            // 是否存在该属性
            const hasKey = target.hasOwnProperty(key);
            // 新增：获取旧值
            const oldValue = target[key];
            // 赋值新值
            Reflect.set(target, key, newValue);
            // 新增：如果新旧值不相等则触发副作用
            if (!(isNaN(oldValue) && isNaN(newValue)) && oldValue !== newValue) {
                trigger(target, key, hasKey ? 'SET' : 'ADD');
            }
            return true;
        }

        // ...
    });
}
```

我们只需要在代理对象的 set 配置中判断新旧两值是否相等就可以了，如果不相等再触发副作用。这里需要注意 NaN 的情况，因为 NaN 不等与任何值，则这里还需要判断新旧两值至少有一个不为 NaN 的情况才能触发副作用

### 原型继承

```js
const parentObj = { bar: 1 };
const childObj = {};
const parent = reactive(parentObj);
const child = reactive(childObj);

Object.setPrototypeOf(child, parent);

effect(() => {
    console.log(child.bar);
});

child.bar = 2;
```

如上例子，child 原型继承了 parent 的原型，当触发 child.bar 修改时副作用函数会触发两次，这是为什么呢

首先我们需要弄清楚，既然触发了两次副作用，那么必然收集了两次依赖。回顾一下原型链的知识，当访问的属性不在当前对象时，就会通过原型查找该属性，如果原型没有就向原型的原型查找。例子中的 child 和 parent 否是响应式数据，因此在触发 get 的时候两个数据都会收集依赖

在触发数据更新时和访问类似，当 child 上没有 bar 属性时，就访问 child 的原型，也就是 parent。因此在触发数据更新时两个数据都会触发副作用

弄清楚原理就好解决，我们查看两次触发 getter 时的参数情况

```js
// 访问 child 的 bar 属性触发的getter
get(target, key, receiver) {
    // target 为 childObj
    // receiver 为 child
},

// 访问 parent 的 bar 属性触发的getter
get(target, key, receiver) {
    // target 为 parentObj
    // receiver 为 child
},
```

我们可以看到通过原型链访问 parent.bar 属性时，target 属性为 parentObj，我们可以在 setter 判断 target 属性是否为 getter 的 target，如果相等，说明访问和设置是同一个属性

```js
// 响应式数据
const raw = Symbol('raw');
function reactive(obj) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            // 新增：获取原生数据
            if (key === raw) {
                return target;
            }

            track(target, key);
            return Reflect.get(target, key, receiver);
        },
        set(target, key, newValue, receiver) {
            console.log(target === childObj, receiver === child);
            // 是否存在该属性
            const hasKey = target.hasOwnProperty(key);
            // 获取旧值
            const oldValue = target[key];
            // 赋值新值
            const res = Reflect.set(target, key, newValue, receiver);

            // 如果新旧值都为NaN，或者新旧值相等则不执行副作用
            if ((isNaN(oldValue) && isNaN(newValue)) || oldValue === newValue) {
                return res;
            }

            // 新增：如果触发set的函数不是原数据的代理则不执行副作用（例如原型继承）
            if (receiver[raw] !== target) {
                return res;
            }

            trigger(target, key, hasKey ? 'SET' : 'ADD');
            return res;
        }
        // ...
    });
}
```

创建变量 raw，使用 symbol 使该变量唯一，在 getter 中如果访问 raw 属性则返回原生数据，在 setter 中获取 raw 属性，如果不等于当前 target，说明说明访问和设置不是同一个属性，不需要触发更新依赖

> 注意 Reflect.set(target, key, newValue, receiver) 的第四个参数，这里需要将 setter 参数透传，不然 receiver\[raw\] 始终等于 target

## 深响应式与浅响应式

我们之前实现的响应式都是浅响应式，如果修改了深层数据是不会有响应的，如下：

```js
const obj = reactive({
    a: {
        b: 1
    }
});

effect(() => {
    console.log(obj.a.b);
});

obj.a.b++;
```

使用 obj.a.b 访问 b 属性会先触发 obj 的 getter 获取 a 属性，在从 a 属性中获取 b 属性，但是 a 属性并不是一个响应式的数据，因此不会收集依赖以及触发更新

要使 a 属性变成响应式数据也很简单，那就是在 getter 返回结果之前将其使用 reactive 函数转化成响应式数据

```js
// 响应式数据
function createReactive(
    obj,
    options = {
        shallow: false
    }
) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            // 获取原生数据
            if (key === raw) {
                return target;
            }

            track(target, key);

            const res = Reflect.get(target, key, receiver);

            // 返回值
            if (typeof res === 'object' && !options.shallow) {
                // 新增：如果值是对象/数组 并且 设置了深响应，则返回响应式数据
                return createReactive(res, options);
            } else {
                // 否则返回值
                return res;
            }
        }
        // ...
    });
}
```

我们将之前的 reactive 方法改名为 createReactive，并接受第二个参数 options，判断如果传入了 options.shallow === false 则通过递归返回一个响应式数据，并将参数透传。这样我们就可以通过 options.shallow 配置来实现控制浅响应和深响应了，只需要对 createReactive 进行封装

```js
// 响应式
function reactive(obj) {
    return createReactive(obj);
}

// 浅响应
function shallowReactive(obj) {
    return createReactive(obj, {
        shallow: true
    });
}
```

再次执行开始的例子发现 obj.a.b 修改时，副作用就会触发

## 深只读与浅只读

和深响应和浅响应同理，我们希望对 createReactive 进行封装如下：

```js
// 计算属性
function readonly(obj) {
    return createReactive(obj, {
        readonly: true
    });
}

// 浅计算属性
function shallowReadonly(obj) {
    return createReactive(obj, {
        readonly: true,
        shallow: true
    });
}
```

通过传入 readonly 和 shallow 配置来判断是否是深只读和浅只读，在修改数据时会触发 setter，只需在 setter 中拦截即可，接下来修改 createReactive 函数

```js
// 响应式数据
const raw = Symbol('raw');
function createReactive(
    obj,
    options = {
        shallow: false,
        readonly: false
    }
) {
    return new Proxy(obj, {
        // ...
        set(target, key, newValue, receiver) {
            // 新增：options.readonly判断是否为只读
            if (options.readonly) {
                throw new Error(`${key}为只读属性`);
            }

            // 是否存在该属性
            const hasKey = target.hasOwnProperty(key);
            // 获取旧值
            const oldValue = target[key];
            // 赋值新值
            const res = Reflect.set(target, key, newValue, receiver);

            // 如果新旧值都为NaN，或者新旧值相等则不执行副作用
            if ((isNaN(oldValue) && isNaN(newValue)) || oldValue === newValue) {
                return res;
            }

            // 如果触发set的函数不是原数据的代理则不执行副作用（例如原型继承）
            if (receiver[raw] !== target) {
                return res;
            }

            trigger(target, key, hasKey ? 'SET' : 'ADD');
            return res;
        },
        // ...
        deleteProperty(target, key) {
            // 新增：options.readonly判断是否为只读
            if (options.readonly) {
                throw new Error(`${key}为只读属性`);
            }

            // 是否存在该属性
            const hasKey = target.hasOwnProperty(key);
            const res = hasKey && Reflect.deleteProperty(target, key);
            // 删除成功在触发副作用
            if (res) {
                trigger(target, key, 'DELETE');
            }
            return res;
        }
    });
}
```

在 setter 触发时判断该数据是否设置了只读，如果设置则直接报错。当然在删除属性的时候也需要增加只读判断

到这里还有一个问题，一个数据的属性为只读，那么意味着这个数据的属性无法设置与删除，因此不会触发副作用更新，所以在 getter 中不需要收集只读属性的依赖

```js
function createReactive(
    obj,
    options = {
        shallow: false,
        readonly: false
    }
) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            // 获取原生数据
            if (key === raw) {
                return target;
            }

            // 新增：非只读数据才能收集副作用
            if (!options.readonly) {
                track(target, key);
            }

            const res = Reflect.get(target, key, receiver);

            // 返回值
            if (typeof res === 'object' && !options.shallow) {
                // 如果值是对象/数组 并且 设置了深响应，则返回响应式数据
                return createReactive(res, options);
            } else {
                // 否则返回值
                return res;
            }
        }
        // ...
    });
}
```

判断非只读属性在收集副作用，这样就只读属性就不会被收集副作用，从而节省一下性能

## 代理数组

数组属于异质对象，增删改查方面有所不同，我们要从各个角度兼容数组的代理

### 索引和 length

索引和 length 是数组中可以修改的属性，我们已经实现了其响应式

```js
const arr = reactive([1, 2, 3]);

effect(() => {
    console.log(arr[0]);
});
arr[0] = 0;

effect(() => {
    console.log(arr.length);
});
arr.length = 4;
```

这是因为数组也是对象，相当于修改了对象属性。但是数组有一些特殊的情况，如下：

```js
// 例子1
effect(() => {
    console.log(arr[0], arr[1], arr[2]);
});
arr.length = 2;

// 例子2
effect(() => {
    console.log(arr.length);
});
arr[3] = 4;
```

**当我修改 length 属性时数组中的元素会删除，或者修改索引大于 length 时，length 会改变**，目前这些例子无法触发副作用更新，下面我们对 createReactive 进行升级

首先兼容修改 length 的情况，当 length 小于数组长度我们需要通知 length 和之后的数组项触发副作用

```js
function createReactive(
    obj,
    options = {
        shallow: false,
        readonly: false
    }
) {
    return new Proxy(obj, {
        // ...

        set(target, key, newValue, receiver) {
            // ...

            // 新增：将newValue透传
            trigger(target, key, hasKey ? 'SET' : 'ADD', newValue);
            return res;
        }

        // ...
    });
}
```

我们将修改后的 length 透传，在 trigger 中做处理，因为 trigger 中可以获取到该数组所有的 key 以及对应的副作用

```js
// 将桶中的副作用取出来执行
function trigger(target, key, type, newValue) {
    // 副作用队列
    const effects = new Set();

    const targetMap = bucket.get(target);

    // ...

    // 新增：当数组length属性更新时需要特殊处理
    if (Array.isArray(target) && key === 'length') {
        // 新增：将数组的所有key以及对应的副作用取出，当key大于更新后的length则认为需要更新这个key的副作用
        targetMap.forEach((targetEffects, key) => {
            if (key >= newValue) {
                effects.add(...targetEffects);
            }
        });
    }

    // ...
}
```

trigger 中遍历该数组的 key 以及对应的副作用列表，将大于修改后 length（也就是 newValue） 的 key 触发更新，这样在执行例子 1，就可以触发副作用

之后我们看例子 2，当设置数组索引大于等于 length 的时候需要触发 length 的副作用函数，当设置数组索引小于 length 时则不需要触发

```js
function createReactive(
    obj,
    options = {
        shallow: false,
        readonly: false
    }
) {
    return new Proxy(obj, {
        // ...
        set(target, key, newValue, receiver) {
            // ...

            // trigger类型
            let type = hasKey ? 'SET' : 'ADD';

            // 新增：如果是数组需要根据长度判断类型
            if (Array.isArray(target) && key !== 'length') {
                // 新增：当索引大于等于length时，length会改变，因此判断为ADD
                type = target.length <= key ? 'ADD' : 'SET';
            }

            // ...

            trigger(target, key, type, newValue);
            return res;
        }

        // ...
    });
}
```

我们需要判断当前下标是否需要更新 length，之后在 trigger 中判断并更新 length 相关副作用即可

```js
// 将桶中的副作用取出来执行
function trigger(target, key, type, newValue) {
    // ...

    // 当数组length属性更新时需要特殊处理
    if (Array.isArray(target)) {
        if (key === 'length') {
            // 将数组的所有key以及对应的副作用取出，当key大于更新后的length则认为需要更新这个key的副作用
            targetMap.forEach((targetEffects, key) => {
                if (key >= newValue) {
                    effects.add(...targetEffects);
                }
            });
        } else {
            // 新增：如果是数组数据且通过修改索引修改时，如果是ADD判断索引大于当前数组length，因此需要触发length相关副作用
            if (type === 'ADD') {
                targetMap.has('length') && effects.add(...targetMap.get('length'));
            }
        }
    }

    // ...
}
```

我们在执行例子 2 就可以正常触发副作用了

### 遍历数组

首先列举出遍历数组的方法：for、for...in、for...of、forEach 等。for 循环会访问数组每个值，因此我们不需要做特殊处理。for...in 和对象一样会触发 OwnPropertyKeys 也就是 proxy.ownKeys 配置。接下来就是 for...of 和 forEach 了

forEach 首先会访问数组的 forEach 方法，接着访问数组的 length 属性，上面已经实现了数组长度变化会重新触发 length 属性相关的副作用

for...of 会访问数组 Symbol.iterator 方法并得到一个迭代器进行遍历，for...of 以及迭代器的逻辑如下：

```js
const arr = [1, 2, 3, 4];

arr[Symbol.iterator] = function () {
    const len = this.length;
    let index = 0;
    return {
        next: () => {
            const res = {
                value: this[index],
                done: index >= len
            };
            index++;
            return res;
        }
    };
};

function forOf(arr, cb) {
    const iterator = arr[Symbol.iterator]();

    let done = false;
    while (!done) {
        const res = iterator.next();
        if (res.done) break;
        cb(res.value);
        done = res.done;
    }
}
```

forOf 函数就是模拟 for...of 的实现，内部会获取 Symbol.iterator 方法，通过迭代实现遍历。在迭代器内部访问了数组的 length 属性，通过闭包内的 index 来判断迭代结果

forEach 和 for...of 我们不修改任何代码也可以实现响应式，但是在使用过程中不仅会访问 length 属性，还会访问 forEach 和 Symbol.iterator 属性，这些属性是不需要收集依赖的，因此我们在 getter 中将其排除

```js
function createReactive(
    obj,
    options = {
        shallow: false,
        readonly: false
    }
) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            // 获取原生数据
            if (key === raw) {
                return target;
            }

            // 新增：只读数据、forEach、Symbol.iterator属性不需要收集副作用
            if (!options.readonly && key !== 'forEach' && key !== Symbol.iterator) {
                track(target, key);
            }

            const res = Reflect.get(target, key, receiver);

            // 返回值
            if (typeof res === 'object' && !options.shallow) {
                // 如果值是对象/数组 并且 设置了深响应，则返回响应式数据
                return createReactive(res, options);
            } else {
                // 否则返回值
                return res;
            }
        },
        // ...
    });
}
```

这样我们就支持了所有遍历数组的响应式