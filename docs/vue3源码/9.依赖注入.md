# 依赖注入

依赖注入是 vue 提供的一套 api <code>provide</code>、<code>inject</code>，用于解决 <code>props</code> 属性需要透传的问题

使用 <code>props</code> 属性需要再每一个组件中进行透传，即使使用 <code>v-bind="$attr"</code> 方便很多，但还是需要再每一层组件中都要写该逻辑

![](./9.props.png)

使用依赖注入则会省去很多代码，缺点就是数据注入的位置不清晰

![](./9.provideInject.png)

依赖注入在代码中使用

```vue
<!-- 先辈组件 -->
<script setup>
  import { provide } from 'vue'
  provide(/* 注入名 */ 'message', /* 值 */ 'hello!')
</script>

<!-- 后代组件 -->
<script setup>
  import { inject } from 'vue'
  const message = inject(/* 注入名 */ 'message', /* 默认值 */ 'str')
</script>
```

其中注入名推荐使用 <code>Symbol</code> 这样比较好确定数据注入的来源

依赖注入还提供了全局注入的方式，这样可以在全局范围内的任意组件使用上述方法获取数据

```ts
import { createApp } from 'vue'
const app = createApp({})
app.provide(/* 注入名 */ 'message', /* 值 */ 'hello!')
```

> 如果不希望使用方修改数据，则可以在注入方使用 <code>readOnly</code> 包装

## Provide api

```ts
export function provide<T>(key: InjectionKey<T> | string | number, value: T) {
  // provide是将属性注入在组件实例上，如果没有currentInstance是不行的
  if (!currentInstance) {
    if (__DEV__) {
      warn(`provide() can only be used inside setup().`)
    }
  } else {
    // 获取当前组件实例的provides属性
    let provides = currentInstance.provides 
    // 获取父组件实例的provides属性
    const parentProvides = currentInstance.parent && currentInstance.parent.provides 
    // 在组件实例创建时provides属性默认值就是父组件的provides，如果没有父组件则继承全局的provides配置
    // 如果组件调用provide api的时候当前组件的provides和父组件的相等，则说明子组件没有自己的provides，也就是说子组件第一次调用provide api
    // 这时候需要创建一个子组件的provides，并将其原型改为父组件的provides，利用原型链进行查找注册的值
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides)
    }
    // 将传入的键值对挂载至当前组件实例的provides属性上
    provides[key as string] = value
  }
}
```

首先需要确定 <code>currentInstance</code> 有值，因为 <code>provide</code> 是在 <code>setup</code> 函数执行期间触发的，<code>setup</code> 在触发前设置 <code>currentInstance</code> 为当前组件实例，[如果忘了这里有传送门](/vue3源码/3.setup.html#设置组件实例)

之后判断 <code>parentProvides === provides</code> 也就是当前组件实例的 <code>provides</code> 是否和父组件实例的 <code>provides</code> 为同一个。这里回顾下组件实例创建的时候 <code>provides</code> 属性是赋值为 父组件的 <code>provides</code> 属性，如果没有父组件则赋值为全局的 <code>provides</code> 属性，[如果忘了这里有传送门](/vue3源码/3.setup.html#创建组件实例)。回到代码中，如果是同一个则可以认为当前组件没有属于自己的 <code>provides</code> 属性

那么就需要为当前组件实例创建一个属于自己的 <code>provides</code> 属性，依赖注入是后代组件可以访问先辈组件注入的数据，反之不行，这里将当前组件 <code>provides</code> 继承父组件的 <code>provides</code>，通过原型链的方式可以访问父组件注入的数据

总结一下，是这样的：

```txt
<!-- 如果一个组件数不使用依赖注册那么组件中 Provide 的关系 -->
app(appProvides) => 父组件(appProvides) => 子组件(appProvides)

<!-- 如果在父组件中使用了 provide api -->
app(appProvides) => 父组件(parentProvides = Object.create(appProvides)) => 子组件(parentProvides)
```

在父组件中使用了 provide api 会创建一个 parentProvides 对象将原型改为 appProvides，档子组件实例创建的时候则会复用父组件的 parentProvides，这样子组件可以访问父组件 parentProvides 上的属性，也可以通过原型链访问 appProvides 上的属性

## Inject api

```ts
export function inject(
  key: InjectionKey<any> | string, // 需要获取数据的key
  defaultValue?: unknown, // 默认值
  treatDefaultAsFactory = false
) {
  // 获取当前组件实例
  const instance = currentInstance || currentRenderingInstance
  // inject是获取组件实例上的provides属性，这里必须有组件实例
  if (instance) {
    // instance.parent == null表示在根组件使用inject api，需要获取全局的provides
    const provides =
      instance.parent == null
        ? instance.vnode.appContext && instance.vnode.appContext.provides
        : instance.parent.provides

    if (provides && (key as string | symbol) in provides) {
      // 如果获取的值在provides中直接返回值
      return provides[key as string]
    } else if (arguments.length > 1) {
      // 如果获取的值不在provides中直接返回值，并且传入了默认参数，则返回默认参数
      return treatDefaultAsFactory && isFunction(defaultValue)
        ? defaultValue.call(instance.proxy)
        : defaultValue
    } else if (__DEV__) {
      warn(`injection "${String(key)}" not found.`)
    }
  } else if (__DEV__) {
    warn(`inject() can only be used inside setup() or functional components.`)
  }
}
```

<code>inject</code> 的逻辑就比较简单，获取父组件实例上的 <code>provides</code> 属性并获取访问的值。其中针对根组件中使用 <code>inject</code> 以及传入第二个参数 <code>defaultValue</code> 的边界情况做处理

## 其他模块间数据共享的方式

vue3 composition api 可以将组件间的共用的数据提取出来，并依然保持响应式的特点

```ts
// store.ts
import { ref } from "vue"

const num = ref(0)

export default { num }
```

我们创建一个 <code>store.ts</code> 放置公共数据

```vue
<!-- a.vue -->
<template>
  <button @click="store.num++" >a.vue {{ store.num }}</button>
</template>

<script setup lang="ts">
import store from './store'
</script>

<!-- b.vue -->
<template>
  <button @click="store.num--" >b.vue {{ store.num }}</button>
</template>

<script setup lang="ts">
import store from './store'
</script>
```

之后再 <code>a.vue</code>、<code>b.vue</code> 中分别对 <code>store.ts</code> 中导出的变量进行修改，变量 <code>num</code> 可以在两个组件之间显示、修改、触发组件更新

那么这种 <code>import/export</code> 的方式和 <code>provide/inject</code> 的方式有什么区别呢？

- **作用域不同**，<code>import/export</code> 只要导入就可以覆盖所有模块。<code>provide/inject</code> 则只能覆盖后代组件
- **数据流向不同**，<code>import/export</code> 没有上下游的区别，任意模块都可以进行访问修改。<code>provide/inject</code> 的数据是从祖先组件流向后代组件，只有后代组件能访问祖先组件的数据。反之不行
- **数据来源**，<code>import/export</code> 需要清除数据从哪个文件导出。<code>provide/inject</code> 则只需要知道祖先组件的数据注入即可

<code>provide/inject</code> 由于不明确知道数据注入的位置，在代码重构上会造成额外的心智负担，如果将某个组件修改文件位置，那么需要搞清楚该组件中的依赖注入是否会出现问题

## 依赖注入场景

<code>provide/inject</code> 在组件开发中使用比较常见，例如 elementUI 中的选择器组件

```vue
<template>
  <el-select v-model="value" multiple>
    <el-option
      v-for="item in options"
      :key="item.value"
      :label="item.label"
      :value="item.value"
    />
  </el-select>
</template>

<script lang="ts" setup>
import { ref } from 'vue'

const value = ref('')
const options = [
  {
    value: 'Option1',
    label: 'Option1',
  },
  {
    value: 'Option2',
    label: 'Option2',
  }
]
</script>
```

例如我们需要一个多选框，需要向 <code>ELSelect</code> 组件传入 <code>multiple</code> 属性，<code>ElOption</code> 组件也需要获取 <code>multiple</code> 属性来改变交互

```ts
// ELSelect.vue
import { project, defineProps } from vue
const props = defineProps<{ multiple: boolean }>()
project("multiple", props.multiple)

// ElOption.vue
import { inject } from vue
const multiple = inject("multiple")
```

<code>ElOption</code> 组件获取 <code>ELSelect</code> 组件注入的数据后就可以修改交互了

```ts
// ElOption.vue
import { getCurrentInstance } from vue
const multiple = getCurrentInstance().parent.props.multiple
```

<code>ElOption</code> 组件也可以直接通过获取父组件实例来访问 <code>multiple</code> 属性，但是需要保证 <code>ElOption</code> 的父组件必须是 <code>ELSelect</code>，当使用以下方式就不适用了

```vue
<template>
  <el-select v-model="value">
    <el-option-group
      v-for="group in options"
      :key="group.label"
      :label="group.label"
    >
      <el-option
        v-for="item in group.options"
        :key="item.value"
        :label="item.label"
        :value="item.value"
      />
    </el-option-group>
  </el-select>
</template>
```

## 总结

<code>provide</code> 用于数据注入，将数据共享给后代组件，本质是在组件挂载阶段将数据挂载到组件实例上，当子组件挂载时继承或赋值父组件的 provide。<code>inject</code> 用于获取组件实例上的 provide，这样就可以在子组件中访问父组件注入的数据了
